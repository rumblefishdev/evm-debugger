{
  "sourceCodes": {
    "0x0000000000c2d145a2526bd8c716263bfebe1a72": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { IERC721Receiver } from \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\nimport \\\"./TransferHelperStructs.sol\\\";\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport { Conduit } from \\\"../conduit/Conduit.sol\\\";\\n\\nimport { ConduitTransfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\nimport {\\n    TransferHelperInterface\\n} from \\\"../interfaces/TransferHelperInterface.sol\\\";\\n\\nimport { TransferHelperErrors } from \\\"../interfaces/TransferHelperErrors.sol\\\";\\n\\n/**\\n * @title TransferHelper\\n * @author stephankmin, stuckinaboot, ryanio\\n * @notice TransferHelper is a utility contract for transferring\\n *         ERC20/ERC721/ERC1155 items in bulk to specific recipients.\\n */\\ncontract TransferHelper is TransferHelperInterface, TransferHelperErrors {\\n    // Allow for interaction with the conduit controller.\\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\\n\\n    // Set conduit creation code and runtime code hashes as immutable arguments.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\\n\\n    /**\\n     * @dev Set the supplied conduit controller and retrieve its\\n     *      conduit creation code hash.\\n     *\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) {\\n        // Get the conduit creation code and runtime code hashes from the\\n        // supplied conduit controller and set them as an immutable.\\n        ConduitControllerInterface controller = ConduitControllerInterface(\\n            conduitController\\n        );\\n        (_CONDUIT_CREATION_CODE_HASH, _CONDUIT_RUNTIME_CODE_HASH) = controller\\n            .getConduitCodeHashes();\\n\\n        // Set the supplied conduit controller as an immutable.\\n        _CONDUIT_CONTROLLER = controller;\\n    }\\n\\n    /**\\n     * @notice Transfer multiple ERC20/ERC721/ERC1155 items to\\n     *         specified recipients.\\n     *\\n     * @param items      The items to transfer to an intended recipient.\\n     * @param conduitKey An optional conduit key referring to a conduit through\\n     *                   which the bulk transfer should occur.\\n     *\\n     * @return magicValue A value indicating that the transfers were successful.\\n     */\\n    function bulkTransfer(\\n        TransferHelperItemsWithRecipient[] calldata items,\\n        bytes32 conduitKey\\n    ) external override returns (bytes4 magicValue) {\\n        // Ensure that a conduit key has been supplied.\\n        if (conduitKey == bytes32(0)) {\\n            revert InvalidConduit(conduitKey, address(0));\\n        }\\n\\n        // Use conduit derived from supplied conduit key to perform transfers.\\n        _performTransfersWithConduit(items, conduitKey);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.bulkTransfer.selector;\\n    }\\n\\n    /**\\n     * @notice Perform multiple transfers to specified recipients via the\\n     *         conduit derived from the provided conduit key.\\n     *\\n     * @param transfers  The items to transfer.\\n     * @param conduitKey The conduit key referring to the conduit through\\n     *                   which the bulk transfer should occur.\\n     */\\n    function _performTransfersWithConduit(\\n        TransferHelperItemsWithRecipient[] calldata transfers,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Retrieve total number of transfers and place on stack.\\n        uint256 numTransfers = transfers.length;\\n\\n        // Derive the conduit address from the deployer, conduit key\\n        // and creation code hash.\\n        address conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(_CONDUIT_CONTROLLER),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Declare a variable to store the sum of all items across transfers.\\n        uint256 sumOfItemsAcrossAllTransfers;\\n\\n        // Skip overflow checks: all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each transfer.\\n            for (uint256 i = 0; i < numTransfers; ++i) {\\n                // Retrieve the transfer in question.\\n                TransferHelperItemsWithRecipient calldata transfer = transfers[\\n                    i\\n                ];\\n\\n                // Increment totalItems by the number of items in the transfer.\\n                sumOfItemsAcrossAllTransfers += transfer.items.length;\\n            }\\n        }\\n\\n        // Declare a new array in memory with length totalItems to populate with\\n        // each conduit transfer.\\n        ConduitTransfer[] memory conduitTransfers = new ConduitTransfer[](\\n            sumOfItemsAcrossAllTransfers\\n        );\\n\\n        // Declare an index for storing ConduitTransfers in conduitTransfers.\\n        uint256 itemIndex;\\n\\n        // Skip overflow checks: all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each transfer.\\n            for (uint256 i = 0; i < numTransfers; ++i) {\\n                // Retrieve the transfer in question.\\n                TransferHelperItemsWithRecipient calldata transfer = transfers[\\n                    i\\n                ];\\n\\n                // Retrieve the items of the transfer in question.\\n                TransferHelperItem[] calldata transferItems = transfer.items;\\n\\n                // Ensure recipient is not the zero address.\\n                _checkRecipientIsNotZeroAddress(transfer.recipient);\\n\\n                // Create a boolean indicating whether validateERC721Receiver\\n                // is true and recipient is a contract.\\n                bool callERC721Receiver = transfer.validateERC721Receiver &&\\n                    transfer.recipient.code.length != 0;\\n\\n                // Retrieve the total number of items in the transfer and\\n                // place on stack.\\n                uint256 numItemsInTransfer = transferItems.length;\\n\\n                // Iterate over each item in the transfer to create a\\n                // corresponding ConduitTransfer.\\n                for (uint256 j = 0; j < numItemsInTransfer; ++j) {\\n                    // Retrieve the item from the transfer.\\n                    TransferHelperItem calldata item = transferItems[j];\\n\\n                    if (item.itemType == ConduitItemType.ERC20) {\\n                        // Ensure that the identifier of an ERC20 token is 0.\\n                        if (item.identifier != 0) {\\n                            revert InvalidERC20Identifier();\\n                        }\\n                    }\\n\\n                    // If the item is an ERC721 token and\\n                    // callERC721Receiver is true...\\n                    if (item.itemType == ConduitItemType.ERC721) {\\n                        if (callERC721Receiver) {\\n                            // Check if the recipient implements\\n                            // onERC721Received for the given tokenId.\\n                            _checkERC721Receiver(\\n                                conduit,\\n                                transfer.recipient,\\n                                item.identifier\\n                            );\\n                        }\\n                    }\\n\\n                    // Create a ConduitTransfer corresponding to each\\n                    // TransferHelperItem.\\n                    conduitTransfers[itemIndex] = ConduitTransfer(\\n                        item.itemType,\\n                        item.token,\\n                        msg.sender,\\n                        transfer.recipient,\\n                        item.identifier,\\n                        item.amount\\n                    );\\n\\n                    // Increment the index for storing ConduitTransfers.\\n                    ++itemIndex;\\n                }\\n            }\\n        }\\n\\n        // Attempt the external call to transfer tokens via the derived conduit.\\n        try ConduitInterface(conduit).execute(conduitTransfers) returns (\\n            bytes4 conduitMagicValue\\n        ) {\\n            // Check if the value returned from the external call matches\\n            // the conduit `execute` selector.\\n            if (conduitMagicValue != ConduitInterface.execute.selector) {\\n                // If the external call fails, revert with the conduit key\\n                // and conduit address.\\n                revert InvalidConduit(conduitKey, conduit);\\n            }\\n        } catch Error(string memory reason) {\\n            // Catch reverts with a provided reason string and\\n            // revert with the reason, conduit key and conduit address.\\n            revert ConduitErrorRevertString(reason, conduitKey, conduit);\\n        } catch (bytes memory data) {\\n            // Conduits will throw a custom error when attempting to transfer\\n            // native token item types or an ERC721 item amount other than 1.\\n            // Bubble up these custom errors when encountered. Note that the\\n            // conduit itself will bubble up revert reasons from transfers as\\n            // well, meaning that these errors are not necessarily indicative of\\n            // an issue with the item type or amount in cases where the same\\n            // custom error signature is encountered during a conduit transfer.\\n\\n            // Set initial value of first four bytes of revert data to the mask.\\n            bytes4 customErrorSelector = bytes4(0xffffffff);\\n\\n            // Utilize assembly to read first four bytes (if present) directly.\\n            assembly {\\n                // Combine original mask with first four bytes of revert data.\\n                customErrorSelector := and(\\n                    mload(add(data, 0x20)), // Data begins after length offset.\\n                    customErrorSelector\\n                )\\n            }\\n\\n            // Pass through the custom error in question if the revert data is\\n            // the correct length and matches an expected custom error selector.\\n            if (\\n                data.length == 4 &&\\n                (customErrorSelector == InvalidItemType.selector ||\\n                    customErrorSelector == InvalidERC721TransferAmount.selector)\\n            ) {\\n                // \\\"Bubble up\\\" the revert reason.\\n                assembly {\\n                    revert(add(data, 0x20), 0x04)\\n                }\\n            }\\n\\n            // Catch all other reverts from the external call to the conduit and\\n            // include the conduit's raw revert reason as a data argument to a\\n            // new custom error.\\n            revert ConduitErrorRevertBytes(data, conduitKey, conduit);\\n        }\\n    }\\n\\n    /**\\n     * @notice An internal function to check if a recipient address implements\\n     *         onERC721Received for a given tokenId. Note that this check does\\n     *         not adhere to the safe transfer specification and is only meant\\n     *         to provide an additional layer of assurance that the recipient\\n     *         can receive the tokens — any hooks or post-transfer checks will\\n     *         fail and the caller will be the transfer helper rather than the\\n     *         ERC721 contract. Note that the conduit is set as the operator, as\\n     *         it will be the caller once the transfer is performed.\\n     *\\n     * @param conduit   The conduit to provide as the operator when calling\\n     *                  onERC721Received.\\n     * @param recipient The ERC721 recipient on which to call onERC721Received.\\n     * @param tokenId   The ERC721 tokenId of the token being transferred.\\n     */\\n    function _checkERC721Receiver(\\n        address conduit,\\n        address recipient,\\n        uint256 tokenId\\n    ) internal {\\n        // Check if recipient can receive ERC721 tokens.\\n        try\\n            IERC721Receiver(recipient).onERC721Received(\\n                conduit,\\n                msg.sender,\\n                tokenId,\\n                \\\"\\\"\\n            )\\n        returns (bytes4 selector) {\\n            // Check if onERC721Received selector is valid.\\n            if (selector != IERC721Receiver.onERC721Received.selector) {\\n                // Revert if recipient cannot accept\\n                // ERC721 tokens.\\n                revert InvalidERC721Recipient(recipient);\\n            }\\n        } catch (bytes memory data) {\\n            // \\\"Bubble up\\\" recipient's revert reason.\\n            revert ERC721ReceiverErrorRevertBytes(\\n                data,\\n                recipient,\\n                msg.sender,\\n                tokenId\\n            );\\n        } catch Error(string memory reason) {\\n            // \\\"Bubble up\\\" recipient's revert reason.\\n            revert ERC721ReceiverErrorRevertString(\\n                reason,\\n                recipient,\\n                msg.sender,\\n                tokenId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice An internal function that reverts if the passed-in recipient\\n     *         is the zero address.\\n     *\\n     * @param recipient The recipient on which to perform the check.\\n     */\\n    function _checkRecipientIsNotZeroAddress(address recipient) internal pure {\\n        // Revert if the recipient is the zero address.\\n        if (recipient == address(0x0)) {\\n            revert RecipientCannotBeZeroAddress();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelperStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitItemType } from \\\"../conduit/lib/ConduitEnums.sol\\\";\\n\\n/**\\n * @dev A TransferHelperItem specifies the itemType (ERC20/ERC721/ERC1155),\\n *      token address, token identifier, and amount of the token to be\\n *      transferred via the TransferHelper. For ERC20 tokens, identifier\\n *      must be 0. For ERC721 tokens, amount must be 1.\\n */\\nstruct TransferHelperItem {\\n    ConduitItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A TransferHelperItemsWithRecipient specifies the tokens to transfer\\n *      via the TransferHelper, their intended recipient, and a boolean flag\\n *      indicating whether onERC721Received should be called on a recipient\\n *      contract.\\n */\\nstruct TransferHelperItemsWithRecipient {\\n    TransferHelperItem[] items;\\n    address recipient;\\n    bool validateERC721Receiver;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed(address channel);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update a channel to the\\n     *      current status of that channel.\\n     */\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address indexed channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the first twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit when no\\n     *      initial owner address is supplied.\\n     */\\n    error InvalidInitialOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a new potential owner\\n     *      that is already set.\\n     */\\n    error NewPotentialOwnerAlreadySet(\\n        address conduit,\\n        address newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\n     *      when no new potential owner is currently set.\\n     */\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(bytes32 conduitKey, address initialOwner)\\n        external\\n        returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(address conduit, address newPotentialOwner)\\n        external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(bytes32 conduitKey)\\n        external\\n        view\\n        returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(address conduit)\\n        external\\n        view\\n        returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(address conduit, address channel)\\n        external\\n        view\\n        returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(address conduit)\\n        external\\n        view\\n        returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(address conduit, uint256 channelIndex)\\n        external\\n        view\\n        returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(address conduit)\\n        external\\n        view\\n        returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/Conduit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ConduitItemType } from \\\"./lib/ConduitEnums.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"./lib/ConduitStructs.sol\\\";\\n\\nimport \\\"./lib/ConduitConstants.sol\\\";\\n\\n/**\\n * @title Conduit\\n * @author 0age\\n * @notice This contract serves as an originator for \\\"proxied\\\" transfers. Each\\n *         conduit is deployed and controlled by a \\\"conduit controller\\\" that can\\n *         add and remove \\\"channels\\\" or contracts that can instruct the conduit\\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\\n *         conduit has an owner that can arbitrarily add or remove channels, and\\n *         a malicious or negligent owner can add a channel that allows for any\\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\\n *         cautious with what conduits you give token approvals to!*\\n */\\ncontract Conduit is ConduitInterface, TokenTransferrer {\\n    // Set deployer as an immutable controller that can update channel statuses.\\n    address private immutable _controller;\\n\\n    // Track the status of each channel.\\n    mapping(address => bool) private _channels;\\n\\n    /**\\n     * @notice Ensure that the caller is currently registered as an open channel\\n     *         on the conduit.\\n     */\\n    modifier onlyOpenChannel() {\\n        // Utilize assembly to access channel storage mapping directly.\\n        assembly {\\n            // Write the caller to scratch space.\\n            mstore(ChannelKey_channel_ptr, caller())\\n\\n            // Write the storage slot for _channels to scratch space.\\n            mstore(ChannelKey_slot_ptr, _channels.slot)\\n\\n            // Derive the position in storage of _channels[msg.sender]\\n            // and check if the stored value is zero.\\n            if iszero(\\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\\n            ) {\\n                // The caller is not an open channel; revert with\\n                // ChannelClosed(caller). First, set error signature in memory.\\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\\n\\n                // Next, set the caller as the argument.\\n                mstore(ChannelClosed_channel_ptr, caller())\\n\\n                // Finally, revert, returning full custom error with argument.\\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\\n            }\\n        }\\n\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @notice In the constructor, set the deployer as the controller.\\n     */\\n    constructor() {\\n        // Set the deployer as the controller.\\n        _controller = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        override\\n        onlyOpenChannel\\n        returns (bytes4 magicValue)\\n    {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = transfers.length;\\n\\n        // Iterate over each transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(transfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.execute.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param batchTransfers The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single ERC20/721/1155 item\\n     *         transfers as well as batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param standardTransfers The ERC20/721/1155 item transfers to perform.\\n     * @param batchTransfers    The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = standardTransfers.length;\\n\\n        // Iterate over each standard transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(standardTransfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward aside from the free memory\\n        // pointer having the default value.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeWithBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external override {\\n        // Ensure that the caller is the controller of this contract.\\n        if (msg.sender != _controller) {\\n            revert InvalidController();\\n        }\\n\\n        // Ensure that the channel does not already have the indicated status.\\n        if (_channels[channel] == isOpen) {\\n            revert ChannelStatusAlreadySet(channel, isOpen);\\n        }\\n\\n        // Update the status of the channel.\\n        _channels[channel] = isOpen;\\n\\n        // Emit a corresponding event.\\n        emit ChannelUpdated(channel, isOpen);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a given ERC20/721/1155 item. Note that\\n     *      channels are expected to implement checks against transferring any\\n     *      zero-amount items if that constraint is desired.\\n     *\\n     * @param item The ERC20/721/1155 item to transfer.\\n     */\\n    function _transfer(ConduitTransfer calldata item) internal {\\n        // Determine the transfer method based on the respective item type.\\n        if (item.itemType == ConduitItemType.ERC20) {\\n            // Transfer ERC20 token. Note that item.identifier is ignored and\\n            // therefore ERC20 transfer items are potentially malleable — this\\n            // check should be performed by the calling channel if a constraint\\n            // on item malleability is desired.\\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\\n        } else if (item.itemType == ConduitItemType.ERC721) {\\n            // Ensure that exactly one 721 item is being transferred.\\n            if (item.amount != 1) {\\n                revert InvalidERC721TransferAmount();\\n            }\\n\\n            // Transfer ERC721 token.\\n            _performERC721Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier\\n            );\\n        } else if (item.itemType == ConduitItemType.ERC1155) {\\n            // Transfer ERC1155 token.\\n            _performERC1155Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier,\\n                item.amount\\n            );\\n        } else {\\n            // Throw with an error.\\n            revert InvalidItemType();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\n\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TransferHelperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {\\n    TransferHelperItem,\\n    TransferHelperItemsWithRecipient\\n} from \\\"../helpers/TransferHelperStructs.sol\\\";\\n\\ninterface TransferHelperInterface {\\n    /**\\n     * @notice Transfer multiple items to a single recipient.\\n     *\\n     * @param items The items to transfer.\\n     * @param conduitKey  The key of the conduit performing the bulk transfer.\\n     */\\n    function bulkTransfer(\\n        TransferHelperItemsWithRecipient[] calldata items,\\n        bytes32 conduitKey\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TransferHelperErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title TransferHelperErrors\\n */\\ninterface TransferHelperErrors {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers with a\\n     *      NATIVE itemType.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an ERC721 transfer\\n     *      to an invalid recipient.\\n     */\\n    error InvalidERC721Recipient(address recipient);\\n\\n    /**\\n     * @dev Revert with an error when a call to a ERC721 receiver reverts with\\n     *      bytes data.\\n     */\\n    error ERC721ReceiverErrorRevertBytes(\\n        bytes reason,\\n        address receiver,\\n        address sender,\\n        uint256 identifier\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a call to a ERC721 receiver reverts with\\n     *      string reason.\\n     */\\n    error ERC721ReceiverErrorRevertString(\\n        string reason,\\n        address receiver,\\n        address sender,\\n        uint256 identifier\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token has an invalid identifier.\\n     */\\n    error InvalidERC20Identifier();\\n\\n    /**\\n     * @dev Revert with an error if the recipient is the zero address.\\n     */\\n    error RecipientCannotBeZeroAddress();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order referencing an\\n     *      invalid conduit (i.e. one that has not been deployed).\\n     */\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit reverts with a\\n     *      reason string.\\n     */\\n    error ConduitErrorRevertString(\\n        string reason,\\n        bytes32 conduitKey,\\n        address conduit\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit reverts with bytes\\n     *      data.\\n     */\\n    error ConduitErrorRevertBytes(\\n        bytes reason,\\n        bytes32 conduitKey,\\n        address conduit\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\n\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title TokenTransferrer\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\\n *         by conduits deployed by the ConduitController. Use great caution when\\n *         considering these functions for use in other codebases, as there are\\n *         significant side effects and edge cases that need to be thoroughly\\n *         understood and carefully addressed.\\n */\\ncontract TokenTransferrer is TokenTransferrerErrors {\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on the\\n     *      contract performing the transfer.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\n            // Scratch space does not need to be cleared ahead of time, as the\\n            // subsequent check will ensure that either at least a full word of\\n            // return data is received (in which case it will be overwritten) or\\n            // that no data is received (in which case scratch space will be\\n            // ignored) on a successful call to the given token.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                OneWord\\n            )\\n\\n            // Determine whether transfer was successful using status & result.\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // Handle cases where either the transfer failed or no data was\\n            // returned. Group these, as most transfers will succeed with data.\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\n            // but after it's inverted for JUMPI this expression is cheaper.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed: Equivalent\\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\\n                // after it's inverted for JUMPI this expression is cheaper.\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up as long as\\n                            // sufficient gas remains to do so:\\n                            if returndatasize() {\\n                                // Ensure that sufficient gas is available to\\n                                // copy returndata while expanding memory where\\n                                // necessary. Start by computing the word size\\n                                // of returndata and allocated memory. Round up\\n                                // to the nearest full word.\\n                                let returnDataWords := div(\\n                                    add(returndatasize(), AlmostOneWord),\\n                                    OneWord\\n                                )\\n\\n                                // Note: use the free memory pointer in place of\\n                                // msize() to work around a Yul warning that\\n                                // prevents accessing msize directly when the IR\\n                                // pipeline is activated.\\n                                let msizeWords := div(memPointer, OneWord)\\n\\n                                // Next, compute the cost of the returndatacopy.\\n                                let cost := mul(CostPerWord, returnDataWords)\\n\\n                                // Then, compute cost of new memory allocation.\\n                                if gt(returnDataWords, msizeWords) {\\n                                    cost := add(\\n                                        cost,\\n                                        add(\\n                                            mul(\\n                                                sub(\\n                                                    returnDataWords,\\n                                                    msizeWords\\n                                                ),\\n                                                CostPerWord\\n                                            ),\\n                                            div(\\n                                                sub(\\n                                                    mul(\\n                                                        returnDataWords,\\n                                                        returnDataWords\\n                                                    ),\\n                                                    mul(msizeWords, msizeWords)\\n                                                ),\\n                                                MemoryExpansionCoefficient\\n                                            )\\n                                        )\\n                                    )\\n                                }\\n\\n                                // Finally, add a small constant and compare to\\n                                // gas remaining; bubble up the revert data if\\n                                // enough gas is still available.\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                                    // Copy returndata to memory; overwrite\\n                                    // existing memory.\\n                                    returndatacopy(0, 0, returndatasize())\\n\\n                                    // Revert, specifying memory region with\\n                                    // copied returndata.\\n                                    revert(0, returndatasize())\\n                                }\\n                            }\\n\\n                            // Otherwise revert with a generic error message.\\n                            mstore(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_signature\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n                            revert(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false or non-compliant return values.\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n                        revert(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise, revert with error about token not having code:\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Otherwise, the token just returned no data despite the call\\n                // having succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer. Note that this function does\\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\\n     *      does not use `safeTransferFrom`).\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     */\\n    function _performERC721Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data to memory starting with function selector.\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\n            mstore(ERC721_transferFrom_from_ptr, from)\\n            mstore(ERC721_transferFrom_to_ptr, to)\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC721_transferFrom_sig_ptr,\\n                ERC721_transferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The id to transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC1155Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The following memory slots will be used when populating call data\\n            // for the transfer; read the values and restore them later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n            let slot0x80 := mload(Slot0x80)\\n            let slot0xA0 := mload(Slot0xA0)\\n            let slot0xC0 := mload(Slot0xC0)\\n\\n            // Write call data into memory, beginning with function selector.\\n            mstore(\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_signature\\n            )\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n            mstore(\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\n                ERC1155_safeTransferFrom_data_length_offset\\n            )\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer. NOTE: this function is not\\n     *      memory-safe; it will overwrite existing memory, restore the free\\n     *      memory pointer to the default value, and overwrite the zero slot.\\n     *      This function should only be called once memory is no longer\\n     *      required and when uninitialized arrays are not utilized, and memory\\n     *      should be considered fully corrupted (aside from the existence of a\\n     *      default-value free memory pointer) after calling this function.\\n     *\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\n     */\\n    function _performERC1155BatchTransfers(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) internal {\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\n        assembly {\\n            let len := batchTransfers.length\\n            // Pointer to first head in the array, which is offset to the struct\\n            // at each index. This gets incremented after each loop to avoid\\n            // multiplying by 32 to get the offset for each element.\\n            let nextElementHeadPtr := batchTransfers.offset\\n\\n            // Pointer to beginning of the head of the array. This is the\\n            // reference position each offset references. It's held static to\\n            // let each loop calculate the data position for an element.\\n            let arrayHeadPtr := nextElementHeadPtr\\n\\n            // Write the function selector, which will be reused for each call:\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\n            mstore(\\n                ConduitBatch1155Transfer_from_offset,\\n                ERC1155_safeBatchTransferFrom_signature\\n            )\\n\\n            // Iterate over each batch transfer.\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 1)\\n            } {\\n                // Read the offset to the beginning of the element and add\\n                // it to pointer to the beginning of the array head to get\\n                // the absolute position of the element in calldata.\\n                let elementPtr := add(\\n                    arrayHeadPtr,\\n                    calldataload(nextElementHeadPtr)\\n                )\\n\\n                // Retrieve the token from calldata.\\n                let token := calldataload(elementPtr)\\n\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Get the total number of supplied ids.\\n                let idsLength := calldataload(\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\n                )\\n\\n                // Determine the expected offset for the amounts array.\\n                let expectedAmountsOffset := add(\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\n                    mul(idsLength, OneWord)\\n                )\\n\\n                // Validate struct encoding.\\n                let invalidEncoding := iszero(\\n                    and(\\n                        // ids.length == amounts.length\\n                        eq(\\n                            idsLength,\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\n                        ),\\n                        and(\\n                            // ids_offset == 0xa0\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_ids_head_offset\\n                                    )\\n                                ),\\n                                ConduitBatch1155Transfer_ids_length_offset\\n                            ),\\n                            // amounts_offset == 0xc0 + ids.length*32\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatchTransfer_amounts_head_offset\\n                                    )\\n                                ),\\n                                expectedAmountsOffset\\n                            )\\n                        )\\n                    )\\n                )\\n\\n                // Revert with an error if the encoding is not valid.\\n                if invalidEncoding {\\n                    mstore(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_selector\\n                    )\\n                    revert(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_length\\n                    )\\n                }\\n\\n                // Update the offset position for the next loop\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\n\\n                // Copy the first section of calldata (before dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\n                    ConduitBatch1155Transfer_usable_head_size\\n                )\\n\\n                // Determine size of calldata required for ids and amounts. Note\\n                // that the size includes both lengths as well as the data.\\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\\n\\n                // Update the offset for the data array in memory.\\n                mstore(\\n                    BatchTransfer1155Params_data_head_ptr,\\n                    add(\\n                        BatchTransfer1155Params_ids_length_offset,\\n                        idsAndAmountsSize\\n                    )\\n                )\\n\\n                // Set the length of the data array in memory to zero.\\n                mstore(\\n                    add(\\n                        BatchTransfer1155Params_data_length_basePtr,\\n                        idsAndAmountsSize\\n                    ),\\n                    0\\n                )\\n\\n                // Determine the total calldata size for the call to transfer.\\n                let transferDataSize := add(\\n                    BatchTransfer1155Params_calldata_baseSize,\\n                    idsAndAmountsSize\\n                )\\n\\n                // Copy second section of calldata (including dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ids_length_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\n                    idsAndAmountsSize\\n                )\\n\\n                // Perform the call to transfer 1155 tokens.\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\n                    transferDataSize, // Location of the length of callData.\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up as long as\\n                    // sufficient gas remains to do so:\\n                    if returndatasize() {\\n                        // Ensure that sufficient gas is available to copy\\n                        // returndata while expanding memory where necessary.\\n                        // Start by computing word size of returndata and\\n                        // allocated memory. Round up to the nearest full word.\\n                        let returnDataWords := div(\\n                            add(returndatasize(), AlmostOneWord),\\n                            OneWord\\n                        )\\n\\n                        // Note: use transferDataSize in place of msize() to\\n                        // work around a Yul warning that prevents accessing\\n                        // msize directly when the IR pipeline is activated.\\n                        // The free memory pointer is not used here because\\n                        // this function does almost all memory management\\n                        // manually and does not update it, and transferDataSize\\n                        // should be the largest memory value used (unless a\\n                        // previous batch was larger).\\n                        let msizeWords := div(transferDataSize, OneWord)\\n\\n                        // Next, compute the cost of the returndatacopy.\\n                        let cost := mul(CostPerWord, returnDataWords)\\n\\n                        // Then, compute cost of new memory allocation.\\n                        if gt(returnDataWords, msizeWords) {\\n                            cost := add(\\n                                cost,\\n                                add(\\n                                    mul(\\n                                        sub(returnDataWords, msizeWords),\\n                                        CostPerWord\\n                                    ),\\n                                    div(\\n                                        sub(\\n                                            mul(\\n                                                returnDataWords,\\n                                                returnDataWords\\n                                            ),\\n                                            mul(msizeWords, msizeWords)\\n                                        ),\\n                                        MemoryExpansionCoefficient\\n                                    )\\n                                )\\n                            )\\n                        }\\n\\n                        // Finally, add a small constant and compare to gas\\n                        // remaining; bubble up the revert data if enough gas is\\n                        // still available.\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\n                            // Copy returndata to memory; overwrite existing.\\n                            returndatacopy(0, 0, returndatasize())\\n\\n                            // Revert with memory region containing returndata.\\n                            revert(0, returndatasize())\\n                        }\\n                    }\\n\\n                    // Set the error signature.\\n                    mstore(\\n                        0,\\n                        ERC1155BatchTransferGenericFailure_error_signature\\n                    )\\n\\n                    // Write the token.\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\n\\n                    // Increase the offset to ids by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_ids_head_ptr,\\n                        ERC1155BatchTransferGenericFailure_ids_offset\\n                    )\\n\\n                    // Increase the offset to amounts by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_amounts_head_ptr,\\n                        add(\\n                            OneWord,\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\n                        )\\n                    )\\n\\n                    // Return modified region. The total size stays the same as\\n                    // `token` uses the same number of bytes as `data.length`.\\n                    revert(0, transferDataSize)\\n                }\\n            }\\n\\n            // Reset the free memory pointer to the default value; memory must\\n            // be assumed to be dirtied and not reused from this point forward.\\n            // Also note that the zero slot is not reset to zero, meaning empty\\n            // arrays cannot be safely created or utilized until it is restored.\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n// error ChannelClosed(address channel)\\nuint256 constant ChannelClosed_error_signature = (\\n    0x93daadf200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ChannelClosed_error_ptr = 0x00;\\nuint256 constant ChannelClosed_channel_ptr = 0x4;\\nuint256 constant ChannelClosed_error_length = 0x24;\\n\\n// For the mapping:\\n// mapping(address => bool) channels\\n// The position in storage for a particular account is:\\n// keccak256(abi.encode(account, channels.slot))\\nuint256 constant ChannelKey_channel_ptr = 0x00;\\nuint256 constant ChannelKey_slot_ptr = 0x20;\\nuint256 constant ChannelKey_length = 0x40;\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\nuint256 constant AlmostOneWord = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\nuint256 constant Slot0xC0 = 0xc0;\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\n);\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\n// abi.encodeWithSignature(\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\n// )\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\n\\n// 4 + 32 * 5 == 164\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\n// abi.encodeWithSignature(\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\n// )\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\n\\n// 4 + 32 * 4 == 132\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\n\\n// Values are offset by 32 bytes in order to write the token to the beginning\\n// in the event of a revert\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\n\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\n\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\n\\n// Note: abbreviated version of above constant to adhere to line length limit.\\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\\n\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenTransferrerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title TokenTransferrerErrors\\n */\\ninterface TokenTransferrerErrors {\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has unused parameters. This includes both the token and the\\n     *      identifier parameters for native transfers as well as the identifier\\n     *      parameter for ERC20 transfers. Note that the conduit does not\\n     *      perform this check, leaving it up to the calling channel to enforce\\n     *      when desired.\\n     */\\n    error UnusedItemParameters();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\n     *      transfer using calldata not produced by default ABI encoding or with\\n     *      different lengths for ids and amounts arrays.\\n     */\\n    error Invalid1155BatchTransferEncoding();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "0x1e0049783f008a0085193e00003d00cd54003c71": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/conduit/Conduit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ConduitItemType } from \\\"./lib/ConduitEnums.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"./lib/ConduitStructs.sol\\\";\\n\\nimport \\\"./lib/ConduitConstants.sol\\\";\\n\\n/**\\n * @title Conduit\\n * @author 0age\\n * @notice This contract serves as an originator for \\\"proxied\\\" transfers. Each\\n *         conduit is deployed and controlled by a \\\"conduit controller\\\" that can\\n *         add and remove \\\"channels\\\" or contracts that can instruct the conduit\\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\\n *         conduit has an owner that can arbitrarily add or remove channels, and\\n *         a malicious or negligent owner can add a channel that allows for any\\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\\n *         cautious with what conduits you give token approvals to!*\\n */\\ncontract Conduit is ConduitInterface, TokenTransferrer {\\n    // Set deployer as an immutable controller that can update channel statuses.\\n    address private immutable _controller;\\n\\n    // Track the status of each channel.\\n    mapping(address => bool) private _channels;\\n\\n    /**\\n     * @notice Ensure that the caller is currently registered as an open channel\\n     *         on the conduit.\\n     */\\n    modifier onlyOpenChannel() {\\n        // Utilize assembly to access channel storage mapping directly.\\n        assembly {\\n            // Write the caller to scratch space.\\n            mstore(ChannelKey_channel_ptr, caller())\\n\\n            // Write the storage slot for _channels to scratch space.\\n            mstore(ChannelKey_slot_ptr, _channels.slot)\\n\\n            // Derive the position in storage of _channels[msg.sender]\\n            // and check if the stored value is zero.\\n            if iszero(\\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\\n            ) {\\n                // The caller is not an open channel; revert with\\n                // ChannelClosed(caller). First, set error signature in memory.\\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\\n\\n                // Next, set the caller as the argument.\\n                mstore(ChannelClosed_channel_ptr, caller())\\n\\n                // Finally, revert, returning full custom error with argument.\\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\\n            }\\n        }\\n\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @notice In the constructor, set the deployer as the controller.\\n     */\\n    constructor() {\\n        // Set the deployer as the controller.\\n        _controller = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        override\\n        onlyOpenChannel\\n        returns (bytes4 magicValue)\\n    {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = transfers.length;\\n\\n        // Iterate over each transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(transfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.execute.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param batchTransfers The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single ERC20/721/1155 item\\n     *         transfers as well as batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param standardTransfers The ERC20/721/1155 item transfers to perform.\\n     * @param batchTransfers    The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = standardTransfers.length;\\n\\n        // Iterate over each standard transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(standardTransfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward aside from the free memory\\n        // pointer having the default value.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeWithBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external override {\\n        // Ensure that the caller is the controller of this contract.\\n        if (msg.sender != _controller) {\\n            revert InvalidController();\\n        }\\n\\n        // Ensure that the channel does not already have the indicated status.\\n        if (_channels[channel] == isOpen) {\\n            revert ChannelStatusAlreadySet(channel, isOpen);\\n        }\\n\\n        // Update the status of the channel.\\n        _channels[channel] = isOpen;\\n\\n        // Emit a corresponding event.\\n        emit ChannelUpdated(channel, isOpen);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a given ERC20/721/1155 item. Note that\\n     *      channels are expected to implement checks against transferring any\\n     *      zero-amount items if that constraint is desired.\\n     *\\n     * @param item The ERC20/721/1155 item to transfer.\\n     */\\n    function _transfer(ConduitTransfer calldata item) internal {\\n        // Determine the transfer method based on the respective item type.\\n        if (item.itemType == ConduitItemType.ERC20) {\\n            // Transfer ERC20 token. Note that item.identifier is ignored and\\n            // therefore ERC20 transfer items are potentially malleable — this\\n            // check should be performed by the calling channel if a constraint\\n            // on item malleability is desired.\\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\\n        } else if (item.itemType == ConduitItemType.ERC721) {\\n            // Ensure that exactly one 721 item is being transferred.\\n            if (item.amount != 1) {\\n                revert InvalidERC721TransferAmount();\\n            }\\n\\n            // Transfer ERC721 token.\\n            _performERC721Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier\\n            );\\n        } else if (item.itemType == ConduitItemType.ERC1155) {\\n            // Transfer ERC1155 token.\\n            _performERC1155Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier,\\n                item.amount\\n            );\\n        } else {\\n            // Throw with an error.\\n            revert InvalidItemType();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\n// prettier-ignore\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed(address channel);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update a channel to the\\n     *      current status of that channel.\\n     */\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address indexed channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title TokenTransferrer\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\\n *         by conduits deployed by the ConduitController. Use great caution when\\n *         considering these functions for use in other codebases, as there are\\n *         significant side effects and edge cases that need to be thoroughly\\n *         understood and carefully addressed.\\n */\\ncontract TokenTransferrer is TokenTransferrerErrors {\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on the\\n     *      contract performing the transfer.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\n            // Scratch space does not need to be cleared ahead of time, as the\\n            // subsequent check will ensure that either at least a full word of\\n            // return data is received (in which case it will be overwritten) or\\n            // that no data is received (in which case scratch space will be\\n            // ignored) on a successful call to the given token.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                OneWord\\n            )\\n\\n            // Determine whether transfer was successful using status & result.\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // Handle cases where either the transfer failed or no data was\\n            // returned. Group these, as most transfers will succeed with data.\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\n            // but after it's inverted for JUMPI this expression is cheaper.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed: Equivalent\\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\\n                // after it's inverted for JUMPI this expression is cheaper.\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up as long as\\n                            // sufficient gas remains to do so:\\n                            if returndatasize() {\\n                                // Ensure that sufficient gas is available to\\n                                // copy returndata while expanding memory where\\n                                // necessary. Start by computing the word size\\n                                // of returndata and allocated memory. Round up\\n                                // to the nearest full word.\\n                                let returnDataWords := div(\\n                                    add(returndatasize(), AlmostOneWord),\\n                                    OneWord\\n                                )\\n\\n                                // Note: use the free memory pointer in place of\\n                                // msize() to work around a Yul warning that\\n                                // prevents accessing msize directly when the IR\\n                                // pipeline is activated.\\n                                let msizeWords := div(memPointer, OneWord)\\n\\n                                // Next, compute the cost of the returndatacopy.\\n                                let cost := mul(CostPerWord, returnDataWords)\\n\\n                                // Then, compute cost of new memory allocation.\\n                                if gt(returnDataWords, msizeWords) {\\n                                    cost := add(\\n                                        cost,\\n                                        add(\\n                                            mul(\\n                                                sub(\\n                                                    returnDataWords,\\n                                                    msizeWords\\n                                                ),\\n                                                CostPerWord\\n                                            ),\\n                                            div(\\n                                                sub(\\n                                                    mul(\\n                                                        returnDataWords,\\n                                                        returnDataWords\\n                                                    ),\\n                                                    mul(msizeWords, msizeWords)\\n                                                ),\\n                                                MemoryExpansionCoefficient\\n                                            )\\n                                        )\\n                                    )\\n                                }\\n\\n                                // Finally, add a small constant and compare to\\n                                // gas remaining; bubble up the revert data if\\n                                // enough gas is still available.\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                                    // Copy returndata to memory; overwrite\\n                                    // existing memory.\\n                                    returndatacopy(0, 0, returndatasize())\\n\\n                                    // Revert, specifying memory region with\\n                                    // copied returndata.\\n                                    revert(0, returndatasize())\\n                                }\\n                            }\\n\\n                            // Otherwise revert with a generic error message.\\n                            mstore(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_signature\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n                            revert(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false or non-compliant return values.\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n                        revert(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise, revert with error about token not having code:\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Otherwise, the token just returned no data despite the call\\n                // having succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer. Note that this function does\\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\\n     *      does not use `safeTransferFrom`).\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     */\\n    function _performERC721Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data to memory starting with function selector.\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\n            mstore(ERC721_transferFrom_from_ptr, from)\\n            mstore(ERC721_transferFrom_to_ptr, to)\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC721_transferFrom_sig_ptr,\\n                ERC721_transferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The id to transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC1155Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The following memory slots will be used when populating call data\\n            // for the transfer; read the values and restore them later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n            let slot0x80 := mload(Slot0x80)\\n            let slot0xA0 := mload(Slot0xA0)\\n            let slot0xC0 := mload(Slot0xC0)\\n\\n            // Write call data into memory, beginning with function selector.\\n            mstore(\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_signature\\n            )\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n            mstore(\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\n                ERC1155_safeTransferFrom_data_length_offset\\n            )\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer. NOTE: this function is not\\n     *      memory-safe; it will overwrite existing memory, restore the free\\n     *      memory pointer to the default value, and overwrite the zero slot.\\n     *      This function should only be called once memory is no longer\\n     *      required and when uninitialized arrays are not utilized, and memory\\n     *      should be considered fully corrupted (aside from the existence of a\\n     *      default-value free memory pointer) after calling this function.\\n     *\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\n     */\\n    function _performERC1155BatchTransfers(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) internal {\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\n        assembly {\\n            let len := batchTransfers.length\\n            // Pointer to first head in the array, which is offset to the struct\\n            // at each index. This gets incremented after each loop to avoid\\n            // multiplying by 32 to get the offset for each element.\\n            let nextElementHeadPtr := batchTransfers.offset\\n\\n            // Pointer to beginning of the head of the array. This is the\\n            // reference position each offset references. It's held static to\\n            // let each loop calculate the data position for an element.\\n            let arrayHeadPtr := nextElementHeadPtr\\n\\n            // Write the function selector, which will be reused for each call:\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\n            mstore(\\n                ConduitBatch1155Transfer_from_offset,\\n                ERC1155_safeBatchTransferFrom_signature\\n            )\\n\\n            // Iterate over each batch transfer.\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 1)\\n            } {\\n                // Read the offset to the beginning of the element and add\\n                // it to pointer to the beginning of the array head to get\\n                // the absolute position of the element in calldata.\\n                let elementPtr := add(\\n                    arrayHeadPtr,\\n                    calldataload(nextElementHeadPtr)\\n                )\\n\\n                // Retrieve the token from calldata.\\n                let token := calldataload(elementPtr)\\n\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Get the total number of supplied ids.\\n                let idsLength := calldataload(\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\n                )\\n\\n                // Determine the expected offset for the amounts array.\\n                let expectedAmountsOffset := add(\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\n                    mul(idsLength, OneWord)\\n                )\\n\\n                // Validate struct encoding.\\n                let invalidEncoding := iszero(\\n                    and(\\n                        // ids.length == amounts.length\\n                        eq(\\n                            idsLength,\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\n                        ),\\n                        and(\\n                            // ids_offset == 0xa0\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_ids_head_offset\\n                                    )\\n                                ),\\n                                ConduitBatch1155Transfer_ids_length_offset\\n                            ),\\n                            // amounts_offset == 0xc0 + ids.length*32\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatchTransfer_amounts_head_offset\\n                                    )\\n                                ),\\n                                expectedAmountsOffset\\n                            )\\n                        )\\n                    )\\n                )\\n\\n                // Revert with an error if the encoding is not valid.\\n                if invalidEncoding {\\n                    mstore(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_selector\\n                    )\\n                    revert(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_length\\n                    )\\n                }\\n\\n                // Update the offset position for the next loop\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\n\\n                // Copy the first section of calldata (before dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\n                    ConduitBatch1155Transfer_usable_head_size\\n                )\\n\\n                // Determine size of calldata required for ids and amounts. Note\\n                // that the size includes both lengths as well as the data.\\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\\n\\n                // Update the offset for the data array in memory.\\n                mstore(\\n                    BatchTransfer1155Params_data_head_ptr,\\n                    add(\\n                        BatchTransfer1155Params_ids_length_offset,\\n                        idsAndAmountsSize\\n                    )\\n                )\\n\\n                // Set the length of the data array in memory to zero.\\n                mstore(\\n                    add(\\n                        BatchTransfer1155Params_data_length_basePtr,\\n                        idsAndAmountsSize\\n                    ),\\n                    0\\n                )\\n\\n                // Determine the total calldata size for the call to transfer.\\n                let transferDataSize := add(\\n                    BatchTransfer1155Params_calldata_baseSize,\\n                    idsAndAmountsSize\\n                )\\n\\n                // Copy second section of calldata (including dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ids_length_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\n                    idsAndAmountsSize\\n                )\\n\\n                // Perform the call to transfer 1155 tokens.\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\n                    transferDataSize, // Location of the length of callData.\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up as long as\\n                    // sufficient gas remains to do so:\\n                    if returndatasize() {\\n                        // Ensure that sufficient gas is available to copy\\n                        // returndata while expanding memory where necessary.\\n                        // Start by computing word size of returndata and\\n                        // allocated memory. Round up to the nearest full word.\\n                        let returnDataWords := div(\\n                            add(returndatasize(), AlmostOneWord),\\n                            OneWord\\n                        )\\n\\n                        // Note: use transferDataSize in place of msize() to\\n                        // work around a Yul warning that prevents accessing\\n                        // msize directly when the IR pipeline is activated.\\n                        // The free memory pointer is not used here because\\n                        // this function does almost all memory management\\n                        // manually and does not update it, and transferDataSize\\n                        // should be the largest memory value used (unless a\\n                        // previous batch was larger).\\n                        let msizeWords := div(transferDataSize, OneWord)\\n\\n                        // Next, compute the cost of the returndatacopy.\\n                        let cost := mul(CostPerWord, returnDataWords)\\n\\n                        // Then, compute cost of new memory allocation.\\n                        if gt(returnDataWords, msizeWords) {\\n                            cost := add(\\n                                cost,\\n                                add(\\n                                    mul(\\n                                        sub(returnDataWords, msizeWords),\\n                                        CostPerWord\\n                                    ),\\n                                    div(\\n                                        sub(\\n                                            mul(\\n                                                returnDataWords,\\n                                                returnDataWords\\n                                            ),\\n                                            mul(msizeWords, msizeWords)\\n                                        ),\\n                                        MemoryExpansionCoefficient\\n                                    )\\n                                )\\n                            )\\n                        }\\n\\n                        // Finally, add a small constant and compare to gas\\n                        // remaining; bubble up the revert data if enough gas is\\n                        // still available.\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\n                            // Copy returndata to memory; overwrite existing.\\n                            returndatacopy(0, 0, returndatasize())\\n\\n                            // Revert with memory region containing returndata.\\n                            revert(0, returndatasize())\\n                        }\\n                    }\\n\\n                    // Set the error signature.\\n                    mstore(\\n                        0,\\n                        ERC1155BatchTransferGenericFailure_error_signature\\n                    )\\n\\n                    // Write the token.\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\n\\n                    // Increase the offset to ids by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_ids_head_ptr,\\n                        ERC1155BatchTransferGenericFailure_ids_offset\\n                    )\\n\\n                    // Increase the offset to amounts by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_amounts_head_ptr,\\n                        add(\\n                            OneWord,\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\n                        )\\n                    )\\n\\n                    // Return modified region. The total size stays the same as\\n                    // `token` uses the same number of bytes as `data.length`.\\n                    revert(0, transferDataSize)\\n                }\\n            }\\n\\n            // Reset the free memory pointer to the default value; memory must\\n            // be assumed to be dirtied and not reused from this point forward.\\n            // Also note that the zero slot is not reset to zero, meaning empty\\n            // arrays cannot be safely created or utilized until it is restored.\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\n\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\n// error ChannelClosed(address channel)\\nuint256 constant ChannelClosed_error_signature = (\\n    0x93daadf200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ChannelClosed_error_ptr = 0x00;\\nuint256 constant ChannelClosed_channel_ptr = 0x4;\\nuint256 constant ChannelClosed_error_length = 0x24;\\n\\n// For the mapping:\\n// mapping(address => bool) channels\\n// The position in storage for a particular account is:\\n// keccak256(abi.encode(account, channels.slot))\\nuint256 constant ChannelKey_channel_ptr = 0x00;\\nuint256 constant ChannelKey_slot_ptr = 0x20;\\nuint256 constant ChannelKey_length = 0x40;\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\nuint256 constant AlmostOneWord = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\nuint256 constant Slot0xC0 = 0xc0;\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\n);\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\n// abi.encodeWithSignature(\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\n// )\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\n\\n// 4 + 32 * 5 == 164\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\n// abi.encodeWithSignature(\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\n// )\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\n\\n// 4 + 32 * 4 == 132\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\n\\n// Values are offset by 32 bytes in order to write the token to the beginning\\n// in the event of a revert\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\n\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\n\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\n\\n// Note: abbreviated version of above constant to adhere to line length limit.\\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\\n\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenTransferrerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\n/**\\n * @title TokenTransferrerErrors\\n */\\ninterface TokenTransferrerErrors {\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has unused parameters. This includes both the token and the\\n     *      identifier parameters for native transfers as well as the identifier\\n     *      parameter for ERC20 transfers. Note that the conduit does not\\n     *      perform this check, leaving it up to the calling channel to enforce\\n     *      when desired.\\n     */\\n    error UnusedItemParameters();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\n     *      transfer using calldata not produced by default ABI encoding or with\\n     *      different lengths for ids and amounts arrays.\\n     */\\n    error Invalid1155BatchTransferEncoding();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "0xbe072760153ec7432c36713daba89a4c45de63a0": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TIJSIB.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title: The Infrared Journey Somewhere In Between\\n/// @author: manifold.xyz\\n\\nimport \\\"./manifold/ERC1155Creator.sol\\\";\\n\\n////////////////////////////////////////////////////////////////////////////////\\n//                                                                            //\\n//                                                                            //\\n//    ___________.__                                                          //\\n//    \\\\__    ___/|  |__   ____                                                //\\n//      |    |   |  |  \\\\_/ __ \\\\                                               //\\n//      |    |   |   Y  \\\\  ___/                                               //\\n//      |____|   |___|  /\\\\___  >                                              //\\n//                    \\\\/     \\\\/                                               //\\n//    .___        _____                                .___                   //\\n//    |   | _____/ ____\\\\___________ _______   ____   __| _/                   //\\n//    |   |/    \\\\   __\\\\\\\\_  __ \\\\__  \\\\\\\\_  __ \\\\_/ __ \\\\ / __ |                    //\\n//    |   |   |  \\\\  |   |  | \\\\// __ \\\\|  | \\\\/\\\\  ___// /_/ |                    //\\n//    |___|___|  /__|   |__|  (____  /__|    \\\\___  >____ |                    //\\n//             \\\\/                  \\\\/            \\\\/     \\\\/                    //\\n//         ____.                                                              //\\n//        |    | ____  __ _________  ____   ____ ___.__.                      //\\n//        |    |/  _ \\\\|  |  \\\\_  __ \\\\/    \\\\_/ __ <   |  |                      //\\n//    /\\\\__|    (  <_> )  |  /|  | \\\\/   |  \\\\  ___/\\\\___  |                      //\\n//    \\\\________|\\\\____/|____/ |__|  |___|  /\\\\___  > ____|                      //\\n//                                      \\\\/     \\\\/\\\\/                           //\\n//      _________                            .__                              //\\n//     /   _____/ ____   _____   ______  _  _|  |__   ___________   ____      //\\n//     \\\\_____  \\\\ /  _ \\\\ /     \\\\_/ __ \\\\ \\\\/ \\\\/ /  |  \\\\_/ __ \\\\_  __ \\\\_/ __ \\\\     //\\n//     /        (  <_> )  Y Y  \\\\  ___/\\\\     /|   Y  \\\\  ___/|  | \\\\/\\\\  ___/     //\\n//    /_______  /\\\\____/|__|_|  /\\\\___  >\\\\/\\\\_/ |___|  /\\\\___  >__|    \\\\___  >    //\\n//            \\\\/             \\\\/     \\\\/            \\\\/     \\\\/            \\\\/     //\\n//    .___         __________        __                                       //\\n//    |   | ____   \\\\______   \\\\ _____/  |___  _  __ ____   ____   ____         //\\n//    |   |/    \\\\   |    |  _// __ \\\\   __\\\\ \\\\/ \\\\/ // __ \\\\_/ __ \\\\ /    \\\\        //\\n//    |   |   |  \\\\  |    |   \\\\  ___/|  |  \\\\     /\\\\  ___/\\\\  ___/|   |  \\\\       //\\n//    |___|___|  /  |______  /\\\\___  >__|   \\\\/\\\\_/  \\\\___  >\\\\___  >___|  /       //\\n//             \\\\/          \\\\/     \\\\/                  \\\\/     \\\\/     \\\\/        //\\n//                                                                            //\\n//                                                                            //\\n////////////////////////////////////////////////////////////////////////////////\\n\\n\\ncontract TIJSIB is ERC1155Creator {\\n    constructor() ERC1155Creator(\\\"The Infrared Journey Somewhere In Between\\\", \\\"TIJSIB\\\") {}\\n}\\n\"\r\n    },\r\n    \"contracts/manifold/ERC1155Creator.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\ncontract ERC1155Creator is Proxy {\\n\\n    constructor(string memory name, string memory symbol) {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = 0x6bf5ed59dE0E19999d264746843FF931c0133090;\\n        Address.functionDelegateCall(\\n            0x6bf5ed59dE0E19999d264746843FF931c0133090,\\n            abi.encodeWithSignature(\\\"initialize(string,string)\\\", name, symbol)\\n        );\\n    }\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n     function implementation() public view returns (address) {\\n        return _implementation();\\n    }\\n\\n    function _implementation() internal override view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }    \\n\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "0x6bf5ed59de0e19999d264746843ff931c0133090": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC1155CreatorImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\\\";\\n\\nimport \\\"./core/ERC1155CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC1155Creator implementation\\n */\\ncontract ERC1155CreatorImplementation is AdminControlUpgradeable, ERC1155Upgradeable, ERC1155CreatorCore {\\n\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * Initializer\\n     */\\n    function initialize(string memory _name, string memory _symbol) public initializer {\\n        __ERC1155_init(\\\"\\\");\\n        __Ownable_init();\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155Upgradeable, ERC1155CreatorCore, AdminControlUpgradeable) returns (bool) {\\n        return ERC1155CreatorCore.supportsInterface(interfaceId) || ERC1155Upgradeable.supportsInterface(interfaceId) || AdminControlUpgradeable.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\\n        _approveTransfer(from, to, ids, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired {\\n        requireNonBlacklist(extension);\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired {\\n        requireNonBlacklist(extension);\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_) external override {\\n        requireExtension();\\n        _setBaseTokenURIExtension(uri_, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_, bool identical) external override {\\n        requireExtension();\\n        _setBaseTokenURIExtension(uri_, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override {\\n        requireExtension();\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri_) external override {\\n        requireExtension();\\n        _setTokenURIExtension(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override {\\n        requireExtension();\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i; i < tokenIds.length;) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri_) external override adminRequired {\\n        _setBaseTokenURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri_) external override adminRequired {\\n        _setTokenURI(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i; i < tokenIds.length;) {\\n            _setTokenURI(tokenIds[i], uris[i]);\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseNew}.\\n     */\\n    function mintBaseNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory) {\\n        return _mintNew(address(0), to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseExisting}.\\n     */\\n    function mintBaseExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant adminRequired {\\n        for (uint i; i < tokenIds.length;) {\\n            uint256 tokenId = tokenIds[i];\\n            require(tokenId > 0 && tokenId <= _tokenCount, \\\"Invalid token\\\");\\n            require(_tokensExtension[tokenId] == address(0), \\\"Token created by extension\\\");\\n            unchecked { ++i; }\\n        }\\n        _mintExisting(address(0), to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionNew}.\\n     */\\n    function mintExtensionNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant returns(uint256[] memory tokenIds) {\\n        requireExtension();\\n        return _mintNew(msg.sender, to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionExisting}.\\n     */\\n    function mintExtensionExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant {\\n        requireExtension();\\n        for (uint i; i < tokenIds.length;) {\\n            require(_tokensExtension[tokenIds[i]] == address(msg.sender), \\\"Token not created by this extension\\\");\\n            unchecked { ++i; }\\n        }\\n        _mintExisting(msg.sender, to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev Mint new tokens\\n     */\\n    function _mintNew(address extension, address[] memory to, uint256[] memory amounts, string[] memory uris) internal returns(uint256[] memory tokenIds) {\\n        if (to.length > 1) {\\n            // Multiple receiver.  Give every receiver the same new token\\n            tokenIds = new uint256[](1);\\n            require(uris.length <= 1 && (amounts.length == 1 || to.length == amounts.length), \\\"Invalid input\\\");\\n        } else {\\n            // Single receiver.  Generating multiple tokens\\n            tokenIds = new uint256[](amounts.length);\\n            require(uris.length == 0 || amounts.length == uris.length, \\\"Invalid input\\\");\\n        }\\n\\n        // Assign tokenIds\\n        for (uint i; i < tokenIds.length;) {\\n            ++_tokenCount;\\n            tokenIds[i] = _tokenCount;\\n            // Track the extension that minted the token\\n            _tokensExtension[_tokenCount] = extension;\\n            unchecked { ++i; }\\n        }\\n\\n        if (extension != address(0)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1) {\\n           // Single mint\\n           _mint(to[0], tokenIds[0], amounts[0], new bytes(0));\\n        } else if (to.length > 1) {\\n            // Multiple receivers.  Receiving the same token\\n            if (amounts.length == 1) {\\n                // Everyone receiving the same amount\\n                for (uint i; i < to.length;) {\\n                    _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n                    unchecked { ++i; }\\n                }\\n            } else {\\n                // Everyone receiving different amounts\\n                for (uint i; i < to.length;) {\\n                    _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n                    unchecked { ++i; }\\n                }\\n            }\\n        } else {\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        }\\n\\n        for (uint i; i < tokenIds.length;) {\\n            if (i < uris.length && bytes(uris[i]).length > 0) {\\n                _tokenURIs[tokenIds[i]] = uris[i];\\n            }\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n     * @dev Mint existing tokens\\n     */\\n    function _mintExisting(address extension, address[] memory to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        if (extension != address(0)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1 && amounts.length == 1) {\\n             // Single mint\\n            _mint(to[0], tokenIds[0], amounts[0], new bytes(0));            \\n        } else if (to.length == 1 && tokenIds.length == amounts.length) {\\n            // Batch mint to same receiver\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        } else if (tokenIds.length == 1 && amounts.length == 1) {\\n            // Mint of the same token/token amounts to various receivers\\n            for (uint i; i < to.length;) {\\n                _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n                unchecked { ++i; }\\n            }\\n        } else if (tokenIds.length == 1 && to.length == amounts.length) {\\n            // Mint of the same token with different amounts to different receivers\\n            for (uint i; i < to.length;) {\\n                _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n                unchecked { ++i; }\\n            }\\n        } else if (to.length == tokenIds.length && to.length == amounts.length) {\\n            // Mint of different tokens and different amounts to different receivers\\n            for (uint i; i < to.length;) {\\n                _mint(to[i], tokenIds[i], amounts[i], new bytes(0));\\n                unchecked { ++i; }\\n            }\\n        } else {\\n            revert(\\\"Invalid input\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-burn}.\\n     */\\n    function burn(address account, uint256[] memory tokenIds, uint256[] memory amounts) public virtual override nonReentrant {\\n        require(account == msg.sender || isApprovedForAll(account, msg.sender), \\\"Caller is not owner nor approved\\\");\\n        require(tokenIds.length == amounts.length, \\\"Invalid input\\\");\\n        if (tokenIds.length == 1) {\\n            _burn(account, tokenIds[0], amounts[0]);\\n        } else {\\n            _burnBatch(account, tokenIds, amounts);\\n        }\\n        _postBurn(account, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(0), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev See {ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC1155-uri}.\\n     */\\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\\n        return _tokenURI(tokenId);\\n    }\\n    \\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 tokenId) external view virtual override returns (uint256) {\\n        return _totalSupply[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mint}.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual override {\\n        super._mint(account, id, amount, data);\\n        _totalSupply[id] += amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mintBatch}.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n        for (uint i; i < ids.length;) {\\n            _totalSupply[ids[i]] += amounts[i];\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burn}.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual override {\\n        super._burn(account, id, amount);\\n        _totalSupply[id] -= amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burnBatch}.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual override {\\n        super._burnBatch(account, ids, amounts);\\n        for (uint i; i < ids.length;) {\\n            _totalSupply[ids[i]] -= amounts[i];\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setApproveTransfer}.\\n     */\\n    function setApproveTransfer(address extension) external override adminRequired {\\n        _setApproveTransferBase(extension);\\n    }\\n}\"\r\n    },\r\n    \"contracts/core/CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport \\\"../extensions/ICreatorExtensionTokenURI.sol\\\";\\nimport \\\"../extensions/ICreatorExtensionRoyalties.sol\\\";\\n\\nimport \\\"./ICreatorCore.sol\\\";\\n\\n/**\\n * @dev Core creator implementation\\n */\\nabstract contract CreatorCore is ReentrancyGuard, ICreatorCore, ERC165 {\\n    using Strings for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using AddressUpgradeable for address;\\n\\n    uint256 internal _tokenCount = 0;\\n\\n    // Base approve transfers address location\\n    address internal _approveTransferBase;\\n\\n    // Track registered extensions data\\n    EnumerableSet.AddressSet internal _extensions;\\n    EnumerableSet.AddressSet internal _blacklistedExtensions;\\n    mapping (address => address) internal _extensionPermissions;\\n    mapping (address => bool) internal _extensionApproveTransfers;\\n    \\n    // For tracking which extension a token was minted by\\n    mapping (uint256 => address) internal _tokensExtension;\\n\\n    // The baseURI for a given extension\\n    mapping (address => string) private _extensionBaseURI;\\n    mapping (address => bool) private _extensionBaseURIIdentical;\\n\\n    // The prefix for any tokens with a uri configured\\n    mapping (address => string) private _extensionURIPrefix;\\n\\n    // Mapping for individual token URIs\\n    mapping (uint256 => string) internal _tokenURIs;\\n\\n    // Royalty configurations\\n    struct RoyaltyConfig {\\n        address payable receiver;\\n        uint16 bps;\\n    }\\n    mapping (address => RoyaltyConfig[]) internal _extensionRoyalty;\\n    mapping (uint256 => RoyaltyConfig[]) internal _tokenRoyalty;\\n\\n    bytes4 private constant _CREATOR_CORE_V1 = 0x28f10a21;\\n\\n    /**\\n     * External interface identifiers for royalties\\n     */\\n\\n    /**\\n     *  @dev CreatorCore\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_CREATORCORE = 0xbb3bafd6;\\n\\n    /**\\n     *  @dev Rarible: RoyaltiesV1\\n     *\\n     *  bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *  bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     *\\n     *  => 0xb9c4d9fb ^ 0x0ebd4c7f = 0xb7799584\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_RARIBLE = 0xb7799584;\\n\\n    /**\\n     *  @dev Foundation\\n     *\\n     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\\n     *\\n     *  => 0xd5a06d4c = 0xd5a06d4c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_FOUNDATION = 0xd5a06d4c;\\n\\n    /**\\n     *  @dev EIP-2981\\n     *\\n     * bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n     *\\n     * => 0x2a55205a = 0x2a55205a\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_EIP2981 = 0x2a55205a;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(ICreatorCore).interfaceId || interfaceId == _CREATOR_CORE_V1 || super.supportsInterface(interfaceId)\\n            || interfaceId == _INTERFACE_ID_ROYALTIES_CREATORCORE || interfaceId == _INTERFACE_ID_ROYALTIES_RARIBLE\\n            || interfaceId == _INTERFACE_ID_ROYALTIES_FOUNDATION || interfaceId == _INTERFACE_ID_ROYALTIES_EIP2981;\\n    }\\n\\n    /**\\n     * @dev Only allows registered extensions to call the specified function\\n     */\\n    function requireExtension() internal view {\\n        require(_extensions.contains(msg.sender), \\\"Must be registered extension\\\");\\n    }\\n\\n    /**\\n     * @dev Only allows non-blacklisted extensions\\n     */\\n    function requireNonBlacklist(address extension) internal view {\\n        require(!_blacklistedExtensions.contains(extension), \\\"Extension blacklisted\\\");\\n    }   \\n\\n    /**\\n     * @dev See {ICreatorCore-getExtensions}.\\n     */\\n    function getExtensions() external view override returns (address[] memory extensions) {\\n        extensions = new address[](_extensions.length());\\n        for (uint i; i < _extensions.length();) {\\n            extensions[i] = _extensions.at(i);\\n            unchecked { ++i; }\\n        }\\n        return extensions;\\n    }\\n\\n    /**\\n     * @dev Register an extension\\n     */\\n    function _registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) internal {\\n        require(extension != address(this) && extension.isContract(), \\\"Invalid\\\");\\n        emit ExtensionRegistered(extension, msg.sender);\\n        _extensionBaseURI[extension] = baseURI;\\n        _extensionBaseURIIdentical[extension] = baseURIIdentical;\\n        _extensions.add(extension);\\n        _setApproveTransferExtension(extension, true);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setApproveTransferExtension}.\\n     */\\n    function setApproveTransferExtension(bool enabled) external override {\\n        requireExtension();\\n        _setApproveTransferExtension(msg.sender, enabled);\\n    }\\n\\n    /**\\n     * @dev Set whether or not tokens minted by the extension defers transfer approvals to the extension\\n     */\\n    function _setApproveTransferExtension(address extension, bool enabled) internal virtual;\\n\\n    /**\\n     * @dev Unregister an extension\\n     */\\n    function _unregisterExtension(address extension) internal {\\n        emit ExtensionUnregistered(extension, msg.sender);\\n        _extensions.remove(extension);\\n    }\\n\\n    /**\\n     * @dev Blacklist an extension\\n     */\\n    function _blacklistExtension(address extension) internal {\\n       require(extension != address(0) && extension != address(this), \\\"Cannot blacklist yourself\\\");\\n       if (_extensions.contains(extension)) {\\n           emit ExtensionUnregistered(extension, msg.sender);\\n           _extensions.remove(extension);\\n       }\\n       if (!_blacklistedExtensions.contains(extension)) {\\n           emit ExtensionBlacklisted(extension, msg.sender);\\n           _blacklistedExtensions.add(extension);\\n       }\\n    }\\n\\n    /**\\n     * @dev Set base token uri for an extension\\n     */\\n    function _setBaseTokenURIExtension(string calldata uri, bool identical) internal {\\n        _extensionBaseURI[msg.sender] = uri;\\n        _extensionBaseURIIdentical[msg.sender] = identical;\\n    }\\n\\n    /**\\n     * @dev Set token uri prefix for an extension\\n     */\\n    function _setTokenURIPrefixExtension(string calldata prefix) internal {\\n        _extensionURIPrefix[msg.sender] = prefix;\\n    }\\n\\n    /**\\n     * @dev Set token uri for a token of an extension\\n     */\\n    function _setTokenURIExtension(uint256 tokenId, string calldata uri) internal {\\n        require(_tokensExtension[tokenId] == msg.sender, \\\"Invalid token\\\");\\n        _tokenURIs[tokenId] = uri;\\n    }\\n\\n    /**\\n     * @dev Set base token uri for tokens with no extension\\n     */\\n    function _setBaseTokenURI(string memory uri) internal {\\n        _extensionBaseURI[address(0)] = uri;\\n    }\\n\\n    /**\\n     * @dev Set token uri prefix for tokens with no extension\\n     */\\n    function _setTokenURIPrefix(string calldata prefix) internal {\\n        _extensionURIPrefix[address(0)] = prefix;\\n    }\\n\\n\\n    /**\\n     * @dev Set token uri for a token with no extension\\n     */\\n    function _setTokenURI(uint256 tokenId, string calldata uri) internal {\\n        require(tokenId > 0 && tokenId <= _tokenCount && _tokensExtension[tokenId] == address(0), \\\"Invalid token\\\");\\n        _tokenURIs[tokenId] = uri;\\n    }\\n\\n    /**\\n     * @dev Retrieve a token's URI\\n     */\\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\\n        require(tokenId > 0 && tokenId <= _tokenCount, \\\"Invalid token\\\");\\n\\n        address extension = _tokensExtension[tokenId];\\n        require(!_blacklistedExtensions.contains(extension), \\\"Extension blacklisted\\\");\\n\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            if (bytes(_extensionURIPrefix[extension]).length != 0) {\\n                return string(abi.encodePacked(_extensionURIPrefix[extension],_tokenURIs[tokenId]));\\n            }\\n            return _tokenURIs[tokenId];\\n        }\\n\\n        if (ERC165Checker.supportsInterface(extension, type(ICreatorExtensionTokenURI).interfaceId)) {\\n            return ICreatorExtensionTokenURI(extension).tokenURI(address(this), tokenId);\\n        }\\n\\n        if (!_extensionBaseURIIdentical[extension]) {\\n            return string(abi.encodePacked(_extensionBaseURI[extension], tokenId.toString()));\\n        } else {\\n            return _extensionBaseURI[extension];\\n        }\\n    }\\n\\n    /**\\n     * Get token extension\\n     */\\n    function _tokenExtension(uint256 tokenId) internal view returns (address extension) {\\n        extension = _tokensExtension[tokenId];\\n\\n        require(extension != address(0), \\\"No extension for token\\\");\\n        require(!_blacklistedExtensions.contains(extension), \\\"Extension blacklisted\\\");\\n\\n        return extension;\\n    }\\n\\n    /**\\n     * Helper to get royalties for a token\\n     */\\n    function _getRoyalties(uint256 tokenId) view internal returns (address payable[] memory receivers, uint256[] memory bps) {\\n\\n        // Get token level royalties\\n        RoyaltyConfig[] memory royalties = _tokenRoyalty[tokenId];\\n        if (royalties.length == 0) {\\n            // Get extension specific royalties\\n            address extension = _tokensExtension[tokenId];\\n            if (extension != address(0)) {\\n                if (ERC165Checker.supportsInterface(extension, type(ICreatorExtensionRoyalties).interfaceId)) {\\n                    (receivers, bps) = ICreatorExtensionRoyalties(extension).getRoyalties(address(this), tokenId);\\n                    // Extension override exists, just return that\\n                    if (receivers.length > 0) return (receivers, bps);\\n                }\\n                royalties = _extensionRoyalty[extension];\\n            }\\n        }\\n        if (royalties.length == 0) {\\n            // Get the default royalty\\n            royalties = _extensionRoyalty[address(0)];\\n        }\\n        \\n        if (royalties.length > 0) {\\n            receivers = new address payable[](royalties.length);\\n            bps = new uint256[](royalties.length);\\n            for (uint i; i < royalties.length;) {\\n                receivers[i] = royalties[i].receiver;\\n                bps[i] = royalties[i].bps;\\n                unchecked { ++i; }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Helper to get royalty receivers for a token\\n     */\\n    function _getRoyaltyReceivers(uint256 tokenId) view internal returns (address payable[] memory recievers) {\\n        (recievers, ) = _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * Helper to get royalty basis points for a token\\n     */\\n    function _getRoyaltyBPS(uint256 tokenId) view internal returns (uint256[] memory bps) {\\n        (, bps) = _getRoyalties(tokenId);\\n    }\\n\\n    function _getRoyaltyInfo(uint256 tokenId, uint256 value) view internal returns (address receiver, uint256 amount){\\n        (address payable[] memory receivers, uint256[] memory bps) = _getRoyalties(tokenId);\\n        require(receivers.length <= 1, \\\"More than 1 royalty receiver\\\");\\n        \\n        if (receivers.length == 0) {\\n            return (address(this), 0);\\n        }\\n        return (receivers[0], bps[0]*value/10000);\\n    }\\n\\n    /**\\n     * Set royalties for a token\\n     */\\n    function _setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) internal {\\n       _checkRoyalties(receivers, basisPoints);\\n        delete _tokenRoyalty[tokenId];\\n        _setRoyalties(receivers, basisPoints, _tokenRoyalty[tokenId]);\\n        emit RoyaltiesUpdated(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * Set royalties for all tokens of an extension\\n     */\\n    function _setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) internal {\\n        _checkRoyalties(receivers, basisPoints);\\n        delete _extensionRoyalty[extension];\\n        _setRoyalties(receivers, basisPoints, _extensionRoyalty[extension]);\\n        if (extension == address(0)) {\\n            emit DefaultRoyaltiesUpdated(receivers, basisPoints);\\n        } else {\\n            emit ExtensionRoyaltiesUpdated(extension, receivers, basisPoints);\\n        }\\n    }\\n\\n    /**\\n     * Helper function to check that royalties provided are valid\\n     */\\n    function _checkRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) private pure {\\n        require(receivers.length == basisPoints.length, \\\"Invalid input\\\");\\n        uint256 totalBasisPoints;\\n        for (uint i; i < basisPoints.length;) {\\n            totalBasisPoints += basisPoints[i];\\n            unchecked { ++i; }\\n        }\\n        require(totalBasisPoints < 10000, \\\"Invalid total royalties\\\");\\n    }\\n\\n    /**\\n     * Helper function to set royalties\\n     */\\n    function _setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints, RoyaltyConfig[] storage royalties) private {\\n        for (uint i; i < basisPoints.length;) {\\n            royalties.push(\\n                RoyaltyConfig(\\n                    {\\n                        receiver: receivers[i],\\n                        bps: uint16(basisPoints[i])\\n                    }\\n                )\\n            );\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-getApproveTransfer}.\\n     */\\n    function getApproveTransfer() external view override returns (address) {\\n        return _approveTransferBase;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ERC1155CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"../extensions/ERC1155/IERC1155CreatorExtensionApproveTransfer.sol\\\";\\nimport \\\"../extensions/ERC1155/IERC1155CreatorExtensionBurnable.sol\\\";\\nimport \\\"../permissions/ERC1155/IERC1155CreatorMintPermissions.sol\\\";\\nimport \\\"./IERC1155CreatorCore.sol\\\";\\nimport \\\"./CreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC1155 creator implementation\\n */\\nabstract contract ERC1155CreatorCore is CreatorCore, IERC1155CreatorCore {\\n\\n    uint256 constant public VERSION = 2;\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    string public name;\\n    string public symbol;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorCore, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155CreatorCore).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {CreatorCore-_setApproveTransferExtension}\\n     */\\n    function _setApproveTransferExtension(address extension, bool enabled) internal override {\\n        if (ERC165Checker.supportsInterface(extension, type(IERC1155CreatorExtensionApproveTransfer).interfaceId)) {\\n            _extensionApproveTransfers[extension] = enabled;\\n            emit ExtensionApproveTransferUpdated(extension, enabled);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the base contract's approve transfer contract location\\n     */\\n    function _setApproveTransferBase(address extension) internal {\\n        _approveTransferBase = extension;\\n        emit ApproveTransferUpdated(extension);\\n    }\\n\\n    /**\\n     * @dev Set mint permissions for an extension\\n     */\\n    function _setMintPermissions(address extension, address permissions) internal {\\n        require(_extensions.contains(extension), \\\"Invalid extension\\\");\\n        require(permissions == address(0) || ERC165Checker.supportsInterface(permissions, type(IERC1155CreatorMintPermissions).interfaceId), \\\"Invalid address\\\");\\n        if (_extensionPermissions[extension] != permissions) {\\n            _extensionPermissions[extension] = permissions;\\n            emit MintPermissionsUpdated(extension, permissions, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * Check if an extension can mint\\n     */\\n    function _checkMintPermissions(address[] memory to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        if (_extensionPermissions[msg.sender] != address(0)) {\\n            IERC1155CreatorMintPermissions(_extensionPermissions[msg.sender]).approveMint(msg.sender, to, tokenIds, amounts);\\n        }\\n    }\\n\\n    /**\\n     * Post burn actions\\n     */\\n    function _postBurn(address owner, uint256[] memory tokenIds, uint256[] memory amounts) internal virtual {\\n        require(tokenIds.length > 0, \\\"Invalid input\\\");\\n        address extension = _tokensExtension[tokenIds[0]];\\n        for (uint i; i < tokenIds.length;) {\\n            require(_tokensExtension[tokenIds[i]] == extension, \\\"Mismatched token originators\\\");\\n            unchecked { ++i; }\\n        }\\n        // Callback to originating extension if needed\\n        if (extension != address(0)) {\\n           if (ERC165Checker.supportsInterface(extension, type(IERC1155CreatorExtensionBurnable).interfaceId)) {\\n               IERC1155CreatorExtensionBurnable(extension).onBurn(owner, tokenIds, amounts);\\n           }\\n        }\\n    }\\n\\n    /**\\n     * Approve a transfer\\n     */\\n    function _approveTransfer(address from, address to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        require(tokenIds.length > 0, \\\"Invalid input\\\");\\n        address extension = _tokensExtension[tokenIds[0]];\\n        for (uint i; i < tokenIds.length;) {\\n            require(_tokensExtension[tokenIds[i]] == extension, \\\"Mismatched token originators\\\");\\n            unchecked { ++i; }\\n        }\\n        if (_extensionApproveTransfers[extension]) {\\n            require(IERC1155CreatorExtensionApproveTransfer(extension).approveTransfer(msg.sender, from, to, tokenIds, amounts), \\\"Extension approval failure\\\");\\n        } else if (_approveTransferBase != address(0)) {\\n            require(IERC1155CreatorExtensionApproveTransfer(_approveTransferBase).approveTransfer(msg.sender, from, to, tokenIds, amounts), \\\"Extension approval failure\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/core/ICreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Core creator interface\\n */\\ninterface ICreatorCore is IERC165 {\\n\\n    event ExtensionRegistered(address indexed extension, address indexed sender);\\n    event ExtensionUnregistered(address indexed extension, address indexed sender);\\n    event ExtensionBlacklisted(address indexed extension, address indexed sender);\\n    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);\\n    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);\\n    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);\\n    event ApproveTransferUpdated(address extension);\\n    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);\\n    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);\\n\\n    /**\\n     * @dev gets address of all extensions\\n     */\\n    function getExtensions() external view returns (address[] memory);\\n\\n    /**\\n     * @dev add an extension.  Can only be called by contract owner or admin.\\n     * extension address must point to a contract implementing ICreatorExtension.\\n     * Returns True if newly added, False if already added.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external;\\n\\n    /**\\n     * @dev add an extension.  Can only be called by contract owner or admin.\\n     * extension address must point to a contract implementing ICreatorExtension.\\n     * Returns True if newly added, False if already added.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;\\n\\n    /**\\n     * @dev add an extension.  Can only be called by contract owner or admin.\\n     * Returns True if removed, False if already removed.\\n     */\\n    function unregisterExtension(address extension) external;\\n\\n    /**\\n     * @dev blacklist an extension.  Can only be called by contract owner or admin.\\n     * This function will destroy all ability to reference the metadata of any tokens created\\n     * by the specified extension. It will also unregister the extension if needed.\\n     * Returns True if removed, False if already removed.\\n     */\\n    function blacklistExtension(address extension) external;\\n\\n    /**\\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri) external;\\n\\n    /**\\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\\n     * For tokens with no uri configured, tokenURI will return \\\"uri+tokenId\\\"\\n     */\\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external;\\n\\n    /**\\n     * @dev set the common prefix of an extension.  Can only be called by extension.\\n     * If configured, and a token has a uri set, tokenURI will return \\\"prefixURI+tokenURI\\\"\\n     * Useful if you want to use ipfs/arweave\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;\\n\\n    /**\\n     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\\n     * For tokens with no uri configured, tokenURI will return \\\"uri+tokenId\\\"\\n     */\\n    function setBaseTokenURI(string calldata uri) external;\\n\\n    /**\\n     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\\n     * If configured, and a token has a uri set, tokenURI will return \\\"prefixURI+tokenURI\\\"\\n     * Useful if you want to use ipfs/arweave\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri) external;\\n\\n    /**\\n     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;\\n\\n    /**\\n     * @dev set a permissions contract for an extension.  Used to control minting.\\n     */\\n    function setMintPermissions(address extension, address permissions) external;\\n\\n    /**\\n     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\\n     * from the extension before transferring\\n     */\\n    function setApproveTransferExtension(bool enabled) external;\\n\\n    /**\\n     * @dev get the extension of a given token\\n     */\\n    function tokenExtension(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Set default royalties\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;\\n\\n    /**\\n     * @dev Set royalties of a token\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\\n\\n    /**\\n     * @dev Set royalties of an extension\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\\n\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     */\\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\n    \\n    // Royalty support for various other standards\\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\\n    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\\n\\n    /**\\n     * @dev Set the default approve transfer contract location.\\n     */\\n    function setApproveTransfer(address extension) external; \\n\\n    /**\\n     * @dev Get the default approve transfer contract location.\\n     */\\n    function getApproveTransfer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/core/IERC1155CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"./CreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC1155 creator interface\\n */\\ninterface IERC1155CreatorCore is ICreatorCore {\\n\\n    /**\\n     * @dev mint a token with no extension. Can only be called by an admin.\\n     *\\n     * @param to       - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param amounts  - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     * @param uris     - If no elements, all tokens use the default uri.\\n     *                   If any element is an empty string, the corresponding token uses the default uri.\\n     *\\n     *\\n     * Requirements: If to is a multi-element array, then uris must be empty or single element array\\n     *               If to is a multi-element array, then amounts must be a single element array or a multi-element array of the same size\\n     *               If to is a single element array, uris must be empty or the same length as amounts\\n     *\\n     * Examples:\\n     *    mintBaseNew(['0x....1', '0x....2'], [1], [])\\n     *        Mints a single new token, and gives 1 each to '0x....1' and '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintBaseNew(['0x....1', '0x....2'], [1, 2], [])\\n     *        Mints a single new token, and gives 1 to '0x....1' and 2 to '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintBaseNew(['0x....1'], [1, 2], [\\\"\\\", \\\"http://token2.com\\\"])\\n     *        Mints two new tokens to '0x....1'. 1 of the first token, 2 of the second.  1st token uses default uri, second uses \\\"http://token2.com\\\".\\n     *    \\n     * @return Returns list of tokenIds minted\\n     */\\n    function mintBaseNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev batch mint existing token with no extension. Can only be called by an admin.\\n     *\\n     * @param to        - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param tokenIds  - Can be a single element array (all recipients get the same token) or a multi-element array\\n     * @param amounts   - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     *\\n     * Requirements: If any of the parameters are multi-element arrays, they need to be the same length as other multi-element arrays\\n     *\\n     * Examples:\\n     *    mintBaseExisting(['0x....1', '0x....2'], [1], [10])\\n     *        Mints 10 of tokenId 1 to each of '0x....1' and '0x....2'.\\n     *    \\n     *    mintBaseExisting(['0x....1', '0x....2'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 2 to '0x....2'.\\n     *    \\n     *    mintBaseExisting(['0x....1'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 and 20 of tokenId 2 to '0x....1'.\\n     *    \\n     *    mintBaseExisting(['0x....1', '0x....2'], [1], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 1 to '0x....2'.\\n     *    \\n     */\\n    function mintBaseExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @dev mint a token from an extension. Can only be called by a registered extension.\\n     *\\n     * @param to       - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param amounts  - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     * @param uris     - If no elements, all tokens use the default uri.\\n     *                   If any element is an empty string, the corresponding token uses the default uri.\\n     *\\n     *\\n     * Requirements: If to is a multi-element array, then uris must be empty or single element array\\n     *               If to is a multi-element array, then amounts must be a single element array or a multi-element array of the same size\\n     *               If to is a single element array, uris must be empty or the same length as amounts\\n     *\\n     * Examples:\\n     *    mintExtensionNew(['0x....1', '0x....2'], [1], [])\\n     *        Mints a single new token, and gives 1 each to '0x....1' and '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintExtensionNew(['0x....1', '0x....2'], [1, 2], [])\\n     *        Mints a single new token, and gives 1 to '0x....1' and 2 to '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintExtensionNew(['0x....1'], [1, 2], [\\\"\\\", \\\"http://token2.com\\\"])\\n     *        Mints two new tokens to '0x....1'. 1 of the first token, 2 of the second.  1st token uses default uri, second uses \\\"http://token2.com\\\".\\n     *    \\n     * @return Returns list of tokenIds minted\\n     */\\n    function mintExtensionNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev batch mint existing token from extension. Can only be called by a registered extension.\\n     *\\n     * @param to        - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param tokenIds  - Can be a single element array (all recipients get the same token) or a multi-element array\\n     * @param amounts   - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     *\\n     * Requirements: If any of the parameters are multi-element arrays, they need to be the same length as other multi-element arrays\\n     *\\n     * Examples:\\n     *    mintExtensionExisting(['0x....1', '0x....2'], [1], [10])\\n     *        Mints 10 of tokenId 1 to each of '0x....1' and '0x....2'.\\n     *    \\n     *    mintExtensionExisting(['0x....1', '0x....2'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 2 to '0x....2'.\\n     *    \\n     *    mintExtensionExisting(['0x....1'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 and 20 of tokenId 2 to '0x....1'.\\n     *    \\n     *    mintExtensionExisting(['0x....1', '0x....2'], [1], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 1 to '0x....2'.\\n     *    \\n     */\\n    function mintExtensionExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @dev burn tokens. Can only be called by token owner or approved address.\\n     * On burn, calls back to the registered extension's onBurn method\\n     */\\n    function burn(address account, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given tokenId.\\n     */\\n    function totalSupply(uint256 tokenId) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC1155/IERC1155CreatorExtensionApproveTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * Implement this if you want your extension to approve a transfer\\n */\\ninterface IERC1155CreatorExtensionApproveTransfer is IERC165 {\\n\\n    /**\\n     * @dev Set whether or not the creator contract will check the extension for approval of token transfer\\n     */\\n    function setApproveTransfer(address creator, bool enabled) external;\\n\\n    /**\\n     * @dev Called by creator contract to approve a transfer\\n     */\\n    function approveTransfer(address operator, address from, address to, uint256[] calldata tokenIds, uint256[] calldata amounts) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC1155/IERC1155CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Your extension is required to implement this interface if it wishes\\n * to receive the onBurn callback whenever a token the extension created is\\n * burned\\n */\\ninterface IERC1155CreatorExtensionBurnable is IERC165 {\\n    /**\\n     * @dev callback handler for burn events\\n     */\\n    function onBurn(address owner, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n}\"\r\n    },\r\n    \"contracts/extensions/ICreatorExtensionRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Implement this if you want your extension to have overloadable royalties\\n */\\ninterface ICreatorExtensionRoyalties is IERC165 {\\n\\n    /**\\n     * Get the royalties for a given creator/tokenId\\n     */\\n    function getRoyalties(address creator, uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ICreatorExtensionTokenURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Implement this if you want your extension to have overloadable URI's\\n */\\ninterface ICreatorExtensionTokenURI is IERC165 {\\n\\n    /**\\n     * Get the uri for a given creator/tokenId\\n     */\\n    function tokenURI(address creator, uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/permissions/ERC1155/IERC1155CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155Creator compliant extension contracts.\\n */\\ninterface IERC1155CreatorMintPermissions is IERC165 {\\n\\n    /**\\n     * @dev get approval to mint\\n     */\\n    function approveMint(address extension, address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n}\"\r\n    },\r\n    \"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./IAdminControl.sol\\\";\\n\\nabstract contract AdminControlUpgradeable is OwnableUpgradeable, IAdminControl, ERC165 {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Track registered admins\\n    EnumerableSet.AddressSet private _admins;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IAdminControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Only allows approved admins to call the specified function\\n     */\\n    modifier adminRequired() {\\n        require(owner() == msg.sender || _admins.contains(msg.sender), \\\"AdminControl: Must be owner or admin\\\");\\n        _;\\n    }   \\n\\n    /**\\n     * @dev See {IAdminControl-getAdmins}.\\n     */\\n    function getAdmins() external view override returns (address[] memory admins) {\\n        admins = new address[](_admins.length());\\n        for (uint i = 0; i < _admins.length(); i++) {\\n            admins[i] = _admins.at(i);\\n        }\\n        return admins;\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-approveAdmin}.\\n     */\\n    function approveAdmin(address admin) external override onlyOwner {\\n        if (!_admins.contains(admin)) {\\n            emit AdminApproved(admin, msg.sender);\\n            _admins.add(admin);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-revokeAdmin}.\\n     */\\n    function revokeAdmin(address admin) external override onlyOwner {\\n        if (_admins.contains(admin)) {\\n            emit AdminRevoked(admin, msg.sender);\\n            _admins.remove(admin);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-isAdmin}.\\n     */\\n    function isAdmin(address admin) public override view returns (bool) {\\n        return (owner() == admin || _admins.contains(admin));\\n    }\\n\\n}\"\r\n    },\r\n    \"@manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for admin control\\n */\\ninterface IAdminControl is IERC165 {\\n\\n    event AdminApproved(address indexed account, address indexed sender);\\n    event AdminRevoked(address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev gets address of all admins\\n     */\\n    function getAdmins() external view returns (address[] memory);\\n\\n    /**\\n     * @dev add an admin.  Can only be called by contract owner.\\n     */\\n    function approveAdmin(address admin) external;\\n\\n    /**\\n     * @dev remove an admin.  Can only be called by contract owner.\\n     */\\n    function revokeAdmin(address admin) external;\\n\\n    /**\\n     * @dev checks whether or not given address is an admin\\n     * Returns True if they are\\n     */\\n    function isAdmin(address admin) external view returns (bool);\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155Upgradeable.sol\\\";\\nimport \\\"./IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\\n        __ERC1155_init_unchained(uri_);\\n    }\\n\\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "0x4721dfe67fe46381e2e56eb1e0406e0989bd7b8e": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155Supply is ERC1155 {\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /**\\n     * @dev Indicates whether any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return ERC1155Supply.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                _totalSupply[ids[i]] += amounts[i];\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                uint256 id = ids[i];\\n                uint256 amount = amounts[i];\\n                uint256 supply = _totalSupply[id];\\n                require(supply >= amount, \\\"ERC1155: burn amount exceeds totalSupply\\\");\\n                unchecked {\\n                    _totalSupply[id] = supply - amount;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Alexis.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/*\\r\\n\\t    :::     :::::::::      :::      ::::::::  \\r\\n\\t  :+: :+:   :+:    :+:   :+: :+:   :+:    :+: \\r\\n\\t +:+   +:+  +:+    +:+  +:+   +:+  +:+        \\r\\n\\t+#++:++#++: +#+    +:+ +#++:++#++: +#+        \\r\\n\\t+#+     +#+ +#+    +#+ +#+     +#+ +#+        \\r\\n\\t#+#     #+# #+#    #+# #+#     #+# #+#    #+# \\r\\n\\t###     ### #########  ###     ###  ########  \\r\\n\\r\\n    UAE NFT - Art Dubai | Alexis Christodoulou\\r\\n    All rights reserved 2023\\r\\n    Developed by DeployLabs.io (info@DeployLabs.io)\\r\\n*/\\r\\n\\r\\nimport \\\"./ArtDubai.sol\\\";\\r\\n\\r\\nerror Alexis__EmptyVouchersArray();\\r\\nerror Alexis__VoucherAlreadyUsed();\\r\\n\\r\\nerror Alexis__HashComparisonFailed();\\r\\nerror Alexis__SignatureExpired();\\r\\nerror Alexis__UntrustedSigner();\\r\\nerror Alexis__SignatureAlreadyUsed();\\r\\n\\r\\n/**\\r\\n * @title UAE NFT - Art Dubai | Alexis Christodoulou\\r\\n * @author DeployLabs.io\\r\\n *\\r\\n * @dev This contract is a collection for Art Dubai by Alexis Christodoulou.\\r\\n */\\r\\ncontract ArtDubaiAlexisChristodoulou is ArtDubai {\\r\\n\\t/**\\r\\n\\t * @dev A signature package, that secures the minting of reward tokens.\\r\\n\\t *\\r\\n\\t * @param hash The hash of the minting operation.\\r\\n\\t * @param signature The signature for the hash.\\r\\n\\t * @param signatureValidUntil The timestamp until which the signature is valid.\\r\\n\\t * @param nonce The nonce, that is used to prevent replay attacks.\\r\\n\\t */\\r\\n\\tstruct RewardSignaturePackage {\\r\\n\\t\\tbytes32 hash;\\r\\n\\t\\tbytes signature;\\r\\n\\t\\tuint32 signatureValidUntil;\\r\\n\\t\\tuint64 nonce;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A voucher, that can be used to mint reward tokens.\\r\\n\\t *\\r\\n\\t * @param collection The collection address.\\r\\n\\t * @param tokenId The token ID.\\r\\n\\t */\\r\\n\\tstruct RewardVoucher {\\r\\n\\t\\taddress collection;\\r\\n\\t\\tuint64 tokenId;\\r\\n\\t}\\r\\n\\r\\n\\tevent RewardVoucherUsed(address indexed collection, uint256 indexed tokenId);\\r\\n\\r\\n\\tuint8 private s_daytimeRewardTokenId;\\r\\n\\tuint8 private s_nighttimeRewardTokenId;\\r\\n\\r\\n\\t// Collection address to token ID to used/unused\\r\\n\\tmapping(address => mapping(uint256 => bool)) private s_tokenIdsUsedForRewards;\\r\\n\\r\\n\\tconstructor() ArtDubai(0xaca187d2a59b04b4, 0x89994365E8538F61a906c84cb15B6d415051fed0) {}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Mint reward tokens for the caller.\\r\\n\\t *\\r\\n\\t * @param signaturePackage The signature package.\\r\\n\\t * @param rewardVouchers The reward vouchers to use.\\r\\n\\t */\\r\\n\\tfunction mintRewardTokens(\\r\\n\\t\\tRewardSignaturePackage calldata signaturePackage,\\r\\n\\t\\tRewardVoucher[] calldata rewardVouchers\\r\\n\\t) external {\\r\\n\\t\\tif (rewardVouchers.length == 0) revert Alexis__EmptyVouchersArray();\\r\\n\\r\\n\\t\\tuint8 tokenIdToMint = _itIsDaytime() ? s_daytimeRewardTokenId : s_nighttimeRewardTokenId;\\r\\n\\r\\n\\t\\tfor (uint16 i = 0; i < rewardVouchers.length; i++) {\\r\\n\\t\\t\\tRewardVoucher memory rewardVoucher = rewardVouchers[i];\\r\\n\\t\\t\\tif (s_tokenIdsUsedForRewards[rewardVoucher.collection][rewardVoucher.tokenId])\\r\\n\\t\\t\\t\\trevert Alexis__VoucherAlreadyUsed();\\r\\n\\r\\n\\t\\t\\ts_tokenIdsUsedForRewards[rewardVoucher.collection][rewardVoucher.tokenId] = true;\\r\\n\\t\\t\\temit RewardVoucherUsed(rewardVoucher.collection, rewardVoucher.tokenId);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (signaturePackage.signatureValidUntil < block.timestamp) revert Alexis__SignatureExpired();\\r\\n\\t\\tif (!_isCorrectRewardMintOperationHash(signaturePackage, rewardVouchers, msg.sender))\\r\\n\\t\\t\\trevert Alexis__HashComparisonFailed();\\r\\n\\t\\tif (!_isTrustedSigner(signaturePackage.hash, signaturePackage.signature))\\r\\n\\t\\t\\trevert Alexis__UntrustedSigner();\\r\\n\\t\\tif (s_usedNonces[signaturePackage.nonce]) revert Alexis__SignatureAlreadyUsed();\\r\\n\\r\\n\\t\\ts_numberMinted[tokenIdToMint][msg.sender] += uint16(rewardVouchers.length);\\r\\n\\t\\ts_usedNonces[signaturePackage.nonce] = true;\\r\\n\\r\\n\\t\\t_mint(msg.sender, tokenIdToMint, rewardVouchers.length, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Specify which token IDs are going to be used as reward tokens.\\r\\n\\t *\\r\\n\\t * @param daytimeRewardTokenId The daytime reward token ID.\\r\\n\\t * @param nighttimeRewardTokenId The nighttime reward token ID.\\r\\n\\t */\\r\\n\\tfunction setRewardTokenIds(\\r\\n\\t\\tuint8 daytimeRewardTokenId,\\r\\n\\t\\tuint8 nighttimeRewardTokenId\\r\\n\\t) external onlyOwner {\\r\\n\\t\\ts_daytimeRewardTokenId = daytimeRewardTokenId;\\r\\n\\t\\ts_nighttimeRewardTokenId = nighttimeRewardTokenId;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Get the reward token ID.\\r\\n\\t *\\r\\n\\t * @return daytimeRewardTokenId The daytime reward token ID.\\r\\n\\t * @return nighttimeRewardTokenId The nighttime reward token ID.\\r\\n\\t */\\r\\n\\tfunction getRewardTokenIds()\\r\\n\\t\\tpublic\\r\\n\\t\\tview\\r\\n\\t\\treturns (uint8 daytimeRewardTokenId, uint8 nighttimeRewardTokenId)\\r\\n\\t{\\r\\n\\t\\tdaytimeRewardTokenId = s_daytimeRewardTokenId;\\r\\n\\t\\tnighttimeRewardTokenId = s_nighttimeRewardTokenId;\\r\\n\\t}\\r\\n\\r\\n\\t/// @inheritdoc ArtDubai\\r\\n\\tfunction isTokenForSale(uint8 tokenId) public view override returns (bool isForSale) {\\r\\n\\t\\tisForSale =\\r\\n\\t\\t\\t(tokenId != s_daytimeRewardTokenId) &&\\r\\n\\t\\t\\t(tokenId != s_nighttimeRewardTokenId) &&\\r\\n\\t\\t\\tsuper.isTokenForSale(tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Check if it's daytime in Dubai (GMT+4).\\r\\n\\t *\\r\\n\\t * @return isDaytime True if it's daytime in Dubai.\\r\\n\\t */\\r\\n\\tfunction _itIsDaytime() internal view returns (bool isDaytime) {\\r\\n\\t\\t// Dubai is GMT+4, thus we add 14400 seconds to the current timestamp\\r\\n\\t\\tuint256 hour = ((block.timestamp + 14400) % 86400) / 3600;\\r\\n\\t\\tisDaytime = (hour >= 6) && (hour < 18);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Check whether a message hash is the one that has been signed.\\r\\n\\t *\\r\\n\\t * @param signaturePackage The signature package.\\r\\n\\t * @param mintTo The address to mint to.\\r\\n\\t *\\r\\n\\t * @return isCorrectRewardMintOperationHash Whether the message hash matches the one that has been signed.\\r\\n\\t */\\r\\n\\tfunction _isCorrectRewardMintOperationHash(\\r\\n\\t\\tRewardSignaturePackage calldata signaturePackage,\\r\\n\\t\\tRewardVoucher[] calldata rewardVouchers,\\r\\n\\t\\taddress mintTo\\r\\n\\t) internal view returns (bool isCorrectRewardMintOperationHash) {\\r\\n\\t\\tbytes memory collectionBytes;\\r\\n\\t\\tbytes memory tokenIdBytes;\\r\\n\\r\\n\\t\\tfor (uint16 i = 0; i < rewardVouchers.length; i++) {\\r\\n\\t\\t\\tcollectionBytes = abi.encodePacked(collectionBytes, rewardVouchers[i].collection);\\r\\n\\t\\t\\ttokenIdBytes = abi.encodePacked(tokenIdBytes, rewardVouchers[i].tokenId);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbytes memory message = abi.encodePacked(\\r\\n\\t\\t\\ti_hashSalt,\\r\\n\\t\\t\\tmintTo,\\r\\n\\t\\t\\tuint64(block.chainid),\\r\\n\\t\\t\\tcollectionBytes,\\r\\n\\t\\t\\ttokenIdBytes,\\r\\n\\t\\t\\tsignaturePackage.signatureValidUntil,\\r\\n\\t\\t\\tsignaturePackage.nonce\\r\\n\\t\\t);\\r\\n\\t\\tbytes32 messageHash = keccak256(message);\\r\\n\\r\\n\\t\\tisCorrectRewardMintOperationHash = messageHash == signaturePackage.hash;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ArtDubai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\nimport \\\"./library/operator_filterer/DefaultOperatorFilterer.sol\\\";\\r\\n\\r\\nerror ArtDubai__TokenNotForSale();\\r\\nerror ArtDubai__WrongEtherAmmount();\\r\\nerror ArtDubai__ExceedingMaxSupply();\\r\\nerror ArtDubai__ExceedingTokensPerWalletLimit();\\r\\n\\r\\nerror ArtDubai__ExceedingSignatureMaxQuantity();\\r\\nerror ArtDubai__HashComparisonFailed();\\r\\nerror ArtDubai__SignatureExpired();\\r\\nerror ArtDubai__UntrustedSigner();\\r\\nerror ArtDubai__SignatureAlreadyUsed();\\r\\n\\r\\nerror ArtDubai__InvalidInput();\\r\\nerror ArtDubai__NothingToWithdraw();\\r\\n\\r\\n/**\\r\\n * @dev A struct, that contains the sale conditions for a token.\\r\\n *\\r\\n * @param supplyLimit The maximum amount of tokens that can be minted.\\r\\n * @param maxTokensPerWallet The maximum amount of tokens that can be minted per wallet.\\r\\n * @param weiTokenPrice The price of a token in wei.\\r\\n */\\r\\nstruct SaleConditions {\\r\\n\\tuint16 supplyLimit;\\r\\n\\tuint16 maxTokensPerWallet;\\r\\n\\tuint256 weiTokenPrice;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev A signature package, that secures the minting of tokens.\\r\\n *\\r\\n * @param hash The hash of the minting operation.\\r\\n * @param signature The signature for the hash.\\r\\n * @param signatureValidUntil The timestamp until which the signature is valid.\\r\\n * @param nonce The nonce, that is used to prevent replay attacks.\\r\\n * @param maxQuantity The maximum quantity of tokens that can be minted with this signature.\\r\\n */\\r\\nstruct SignaturePackage {\\r\\n\\tbytes32 hash;\\r\\n\\tbytes signature;\\r\\n\\tuint32 signatureValidUntil;\\r\\n\\tuint64 nonce;\\r\\n\\tuint16 maxQuantity;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Art Dubai\\r\\n * @author DeployLabs.io\\r\\n *\\r\\n * @dev This contract is used as a base contract for all Art Dubai collections.\\r\\n */\\r\\nabstract contract ArtDubai is ERC1155, ERC1155Supply, Ownable, DefaultOperatorFilterer {\\r\\n\\tbytes8 internal immutable i_hashSalt;\\r\\n\\taddress internal immutable i_signerAddress;\\r\\n\\r\\n\\tmapping(uint64 => bool) internal s_usedNonces;\\r\\n\\r\\n\\tmapping(uint8 => SaleConditions) internal s_saleConditions;\\r\\n\\tmapping(uint8 => mapping(address => uint16)) internal s_numberMinted;\\r\\n\\r\\n\\tstring internal s_baseTokenUri;\\r\\n\\r\\n\\tconstructor(bytes8 hashSalt, address signerAddress) ERC1155(\\\"\\\") {\\r\\n\\t\\ti_hashSalt = hashSalt;\\r\\n\\t\\ti_signerAddress = signerAddress;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Mint a token to a specified wallet.\\r\\n\\t *\\r\\n\\t * @param signaturePackage The signature package for security.\\r\\n\\t * @param mintTo The address to mint the token to.\\r\\n\\t * @param tokenId The id of the token to mint.\\r\\n\\t * @param quantity The quantity of tokens to mint.\\r\\n\\t */\\r\\n\\tfunction mint(\\r\\n\\t\\tSignaturePackage calldata signaturePackage,\\r\\n\\t\\taddress mintTo,\\r\\n\\t\\tuint8 tokenId,\\r\\n\\t\\tuint16 quantity\\r\\n\\t) external payable {\\r\\n\\t\\tSaleConditions memory conditions = s_saleConditions[tokenId];\\r\\n\\r\\n\\t\\tif (!isTokenForSale(tokenId)) revert ArtDubai__TokenNotForSale();\\r\\n\\r\\n\\t\\tif (msg.value != conditions.weiTokenPrice * quantity) revert ArtDubai__WrongEtherAmmount();\\r\\n\\t\\tif (totalSupply(tokenId) + quantity > conditions.supplyLimit)\\r\\n\\t\\t\\trevert ArtDubai__ExceedingMaxSupply();\\r\\n\\t\\tif (s_numberMinted[tokenId][mintTo] + quantity > conditions.maxTokensPerWallet)\\r\\n\\t\\t\\trevert ArtDubai__ExceedingTokensPerWalletLimit();\\r\\n\\r\\n\\t\\tif (quantity > signaturePackage.maxQuantity) revert ArtDubai__ExceedingSignatureMaxQuantity();\\r\\n\\t\\tif (signaturePackage.signatureValidUntil < block.timestamp) revert ArtDubai__SignatureExpired();\\r\\n\\t\\tif (!_isCorrectMintOperationHash(signaturePackage, tokenId, mintTo))\\r\\n\\t\\t\\trevert ArtDubai__HashComparisonFailed();\\r\\n\\t\\tif (!_isTrustedSigner(signaturePackage.hash, signaturePackage.signature))\\r\\n\\t\\t\\trevert ArtDubai__UntrustedSigner();\\r\\n\\t\\tif (s_usedNonces[signaturePackage.nonce]) revert ArtDubai__SignatureAlreadyUsed();\\r\\n\\r\\n\\t\\ts_numberMinted[tokenId][mintTo] += quantity;\\r\\n\\t\\ts_usedNonces[signaturePackage.nonce] = true;\\r\\n\\r\\n\\t\\t_mint(mintTo, tokenId, quantity, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Withdraw the balance of the contract.\\r\\n\\t *\\r\\n\\t * @param to The address to send the balance to.\\r\\n\\t */\\r\\n\\tfunction withdraw(address payable to) external onlyOwner {\\r\\n\\t\\tuint256 balance = address(this).balance;\\r\\n\\t\\tif (balance == 0) revert ArtDubai__NothingToWithdraw();\\r\\n\\t\\tif (to == address(0)) revert ArtDubai__InvalidInput();\\r\\n\\r\\n\\t\\tto.transfer(balance);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Set base URI for token metadata.\\r\\n\\t *\\r\\n\\t * @param baseUri The base URI for token metadata.\\r\\n\\t */\\r\\n\\tfunction setBaseUri(string calldata baseUri) external onlyOwner {\\r\\n\\t\\ts_baseTokenUri = baseUri;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sets sale conditions for a set of tokens.\\r\\n\\t *\\r\\n\\t * @param tokenIds Token IDs\\r\\n\\t * @param saleConditions Sale conditions for each token\\r\\n\\t */\\r\\n\\tfunction setSaleConditions(\\r\\n\\t\\tuint8[] calldata tokenIds,\\r\\n\\t\\tSaleConditions[] calldata saleConditions\\r\\n\\t) external onlyOwner {\\r\\n\\t\\tif (tokenIds.length != saleConditions.length) revert ArtDubai__InvalidInput();\\r\\n\\r\\n\\t\\tfor (uint8 i = 0; i < tokenIds.length; i++) {\\r\\n\\t\\t\\ts_saleConditions[tokenIds[i]] = saleConditions[i];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Gets sale conditions for a token.\\r\\n\\t *\\r\\n\\t * @param tokenId Token ID\\r\\n\\t *\\r\\n\\t * @return conditions Sale conditions.\\r\\n\\t */\\r\\n\\tfunction getSaleConditions(\\r\\n\\t\\tuint8 tokenId\\r\\n\\t) external view returns (SaleConditions memory conditions) {\\r\\n\\t\\tconditions = s_saleConditions[tokenId];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Get the number of tokens minted by a wallet.\\r\\n\\t *\\r\\n\\t * @param tokenId The id of the token.\\r\\n\\t * @param wallet The wallet to check.\\r\\n\\t *\\r\\n\\t * @return countMinted The number of tokens minted by the wallet.\\r\\n\\t */\\r\\n\\tfunction getMintedCount(\\r\\n\\t\\tuint8 tokenId,\\r\\n\\t\\taddress wallet\\r\\n\\t) external view returns (uint16 countMinted) {\\r\\n\\t\\tcountMinted = s_numberMinted[tokenId][wallet];\\r\\n\\t}\\r\\n\\r\\n\\t// Overrides for marketplace restrictions.\\r\\n\\tfunction setApprovalForAll(\\r\\n\\t\\taddress operator,\\r\\n\\t\\tbool approved\\r\\n\\t) public override onlyAllowedOperatorApproval(operator) {\\r\\n\\t\\tsuper.setApprovalForAll(operator, approved);\\r\\n\\t}\\r\\n\\r\\n\\tfunction safeTransferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tuint256 amount,\\r\\n\\t\\tbytes memory data\\r\\n\\t) public override onlyAllowedOperator(from) {\\r\\n\\t\\tsuper.safeTransferFrom(from, to, tokenId, amount, data);\\r\\n\\t}\\r\\n\\r\\n\\tfunction safeBatchTransferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256[] memory ids,\\r\\n\\t\\tuint256[] memory amounts,\\r\\n\\t\\tbytes memory data\\r\\n\\t) public virtual override onlyAllowedOperator(from) {\\r\\n\\t\\tsuper.safeBatchTransferFrom(from, to, ids, amounts, data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Check, if a token is for sale.\\r\\n\\t *\\r\\n\\t * @param tokenId The id of the token.\\r\\n\\t *\\r\\n\\t * @return isForSale Whether the token is for sale.\\r\\n\\t */\\r\\n\\tfunction isTokenForSale(uint8 tokenId) public view virtual returns (bool isForSale) {\\r\\n\\t\\tisForSale = s_saleConditions[tokenId].supplyLimit > 0;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Get data used to generate the signature.\\r\\n\\t *\\r\\n\\t * @return hashSalt The hash salt.\\r\\n\\t * @return signerAddress The signer address.\\r\\n\\t */\\r\\n\\tfunction getSignatureData() public view returns (bytes8 hashSalt, address signerAddress) {\\r\\n\\t\\thashSalt = i_hashSalt;\\r\\n\\t\\tsignerAddress = i_signerAddress;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Get the URI for a token.\\r\\n\\t *\\r\\n\\t * @param tokenId The token ID.\\r\\n\\t *\\r\\n\\t * @return uri The URI for the token.\\r\\n\\t */\\r\\n\\tfunction uri(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n\\t\\treturn string(abi.encodePacked(s_baseTokenUri, Strings.toString(tokenId)));\\r\\n\\t}\\r\\n\\r\\n\\t// Override for ERC1155Supply.\\r\\n\\tfunction _beforeTokenTransfer(\\r\\n\\t\\taddress operator,\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256[] memory ids,\\r\\n\\t\\tuint256[] memory amounts,\\r\\n\\t\\tbytes memory data\\r\\n\\t) internal override(ERC1155, ERC1155Supply) {\\r\\n\\t\\tsuper._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Check whether a message hash is the one that has been signed.\\r\\n\\t *\\r\\n\\t * @param signaturePackage The signature package.\\r\\n\\t * @param tokenId The id of the token.\\r\\n\\t * @param mintTo The address to mint to.\\r\\n\\t *\\r\\n\\t * @return isCorrectMintOperationHash Whether the message hash matches the one that has been signed.\\r\\n\\t */\\r\\n\\tfunction _isCorrectMintOperationHash(\\r\\n\\t\\tSignaturePackage calldata signaturePackage,\\r\\n\\t\\tuint8 tokenId,\\r\\n\\t\\taddress mintTo\\r\\n\\t) internal view returns (bool isCorrectMintOperationHash) {\\r\\n\\t\\tbytes memory message = abi.encodePacked(\\r\\n\\t\\t\\ti_hashSalt,\\r\\n\\t\\t\\tmintTo,\\r\\n\\t\\t\\tuint64(block.chainid),\\r\\n\\t\\t\\ttokenId,\\r\\n\\t\\t\\tsignaturePackage.maxQuantity,\\r\\n\\t\\t\\tsignaturePackage.signatureValidUntil,\\r\\n\\t\\t\\tsignaturePackage.nonce\\r\\n\\t\\t);\\r\\n\\t\\tbytes32 messageHash = keccak256(message);\\r\\n\\r\\n\\t\\tisCorrectMintOperationHash = messageHash == signaturePackage.hash;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Check whether a message was signed by a trusted address.\\r\\n\\t *\\r\\n\\t * @param hash The hash of the message.\\r\\n\\t * @param signature The signature of the message.\\r\\n\\t *\\r\\n\\t * @return isTrustedSigner Whether the message was signed by a trusted address.\\r\\n\\t */\\r\\n\\tfunction _isTrustedSigner(\\r\\n\\t\\tbytes32 hash,\\r\\n\\t\\tbytes memory signature\\r\\n\\t) internal view returns (bool isTrustedSigner) {\\r\\n\\t\\tisTrustedSigner = i_signerAddress == ECDSA.recover(hash, signature);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/library/operator_filterer/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title  DefaultOperatorFilterer\\r\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\r\\n */\\r\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\r\\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\\r\\n\\r\\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\\r\\n}\"\r\n    },\r\n    \"contracts/library/operator_filterer/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IOperatorFilterRegistry {\\r\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\r\\n    function register(address registrant) external;\\r\\n    function registerAndSubscribe(address registrant, address subscription) external;\\r\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\r\\n    function unregister(address addr) external;\\r\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\r\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\r\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\r\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\r\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\r\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\r\\n    function subscriptionOf(address addr) external returns (address registrant);\\r\\n    function subscribers(address registrant) external returns (address[] memory);\\r\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\r\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\r\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\r\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\r\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\r\\n    function filteredOperators(address addr) external returns (address[] memory);\\r\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\r\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\r\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\r\\n    function isRegistered(address addr) external returns (bool);\\r\\n    function codeHashOf(address addr) external returns (bytes32);\\r\\n}\"\r\n    },\r\n    \"contracts/library/operator_filterer/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title  OperatorFilterer\\r\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\r\\n *         registrant's entries in the OperatorFilterRegistry.\\r\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\r\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\r\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\r\\n */\\r\\nabstract contract OperatorFilterer {\\r\\n    error OperatorNotAllowed(address operator);\\r\\n\\r\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\r\\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\\r\\n\\r\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\r\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\r\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\r\\n        // order for the modifier to filter addresses.\\r\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\r\\n            if (subscribe) {\\r\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\r\\n            } else {\\r\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\r\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\r\\n                } else {\\r\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier onlyAllowedOperator(address from) virtual {\\r\\n        // Allow spending tokens from addresses with balance\\r\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\r\\n        // from an EOA.\\r\\n        if (from != msg.sender) {\\r\\n            _checkFilterOperator(msg.sender);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\r\\n        _checkFilterOperator(operator);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _checkFilterOperator(address operator) internal view virtual {\\r\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\r\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\r\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\r\\n                revert OperatorNotAllowed(operator);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "0x000000000000aaeb6d7670e522a718067333cd4e": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {EnumerableSet} from \\\"openzeppelin-contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ninterface IOperatorFilterRegistry {\\n    function isOperatorAllowed(address registrant, address operator) external returns (bool);\\n    function register(address registrant) external;\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n    function subscriptionOf(address addr) external returns (address registrant);\\n    function subscribers(address registrant) external returns (address[] memory);\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n    function filteredOperators(address addr) external returns (address[] memory);\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n    function isRegistered(address addr) external returns (bool);\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/OperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {Ownable} from \\\"openzeppelin-contracts/access/Ownable.sol\\\";\\nimport {EnumerableSet} from \\\"openzeppelin-contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {OperatorFilterRegistryErrorsAndEvents} from \\\"./OperatorFilterRegistryErrorsAndEvents.sol\\\";\\n\\n/**\\n * @title  OperatorFilterRegistry\\n * @notice Borrows heavily from the QQL BlacklistOperatorFilter contract:\\n *         https://github.com/qql-art/contracts/blob/main/contracts/BlacklistOperatorFilter.sol\\n * @notice This contracts allows tokens or token owners to register specific addresses or codeHashes that may be\\n * *       restricted according to the isOperatorAllowed function.\\n */\\ncontract OperatorFilterRegistry is IOperatorFilterRegistry, OperatorFilterRegistryErrorsAndEvents {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    /// @dev initialized accounts have a nonzero codehash (see https://eips.ethereum.org/EIPS/eip-1052)\\n    /// Note that this will also be a smart contract's codehash when making calls from its constructor.\\n    bytes32 constant EOA_CODEHASH = keccak256(\\\"\\\");\\n\\n    mapping(address => EnumerableSet.AddressSet) private _filteredOperators;\\n    mapping(address => EnumerableSet.Bytes32Set) private _filteredCodeHashes;\\n    mapping(address => address) private _registrations;\\n    mapping(address => EnumerableSet.AddressSet) private _subscribers;\\n\\n    /**\\n     * @notice restricts method caller to the address or EIP-173 \\\"owner()\\\"\\n     */\\n    modifier onlyAddressOrOwner(address addr) {\\n        if (msg.sender != addr) {\\n            try Ownable(addr).owner() returns (address owner) {\\n                if (msg.sender != owner) {\\n                    revert OnlyAddressOrOwner();\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert NotOwnable();\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool) {\\n        address registration = _registrations[registrant];\\n        if (registration != address(0)) {\\n            EnumerableSet.AddressSet storage filteredOperatorsRef;\\n            EnumerableSet.Bytes32Set storage filteredCodeHashesRef;\\n\\n            filteredOperatorsRef = _filteredOperators[registration];\\n            filteredCodeHashesRef = _filteredCodeHashes[registration];\\n\\n            if (filteredOperatorsRef.contains(operator)) {\\n                revert AddressFiltered(operator);\\n            }\\n            if (operator.code.length > 0) {\\n                bytes32 codeHash = operator.codehash;\\n                if (filteredCodeHashesRef.contains(codeHash)) {\\n                    revert CodeHashFiltered(operator, codeHash);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    //////////////////\\n    // AUTH METHODS //\\n    //////////////////\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external onlyAddressOrOwner(registrant) {\\n        if (_registrations[registrant] != address(0)) {\\n            revert AlreadyRegistered();\\n        }\\n        _registrations[registrant] = registrant;\\n        emit RegistrationUpdated(registrant, true);\\n    }\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address registrant) external onlyAddressOrOwner(registrant) {\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration != registrant) {\\n            _subscribers[registration].remove(registrant);\\n            emit SubscriptionUpdated(registrant, registration, false);\\n        }\\n        _registrations[registrant] = address(0);\\n        emit RegistrationUpdated(registrant, false);\\n    }\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external onlyAddressOrOwner(registrant) {\\n        address registration = _registrations[registrant];\\n        if (registration != address(0)) {\\n            revert AlreadyRegistered();\\n        }\\n        if (registrant == subscription) {\\n            revert CannotSubscribeToSelf();\\n        }\\n        address subscriptionRegistration = _registrations[subscription];\\n        if (subscriptionRegistration == address(0)) {\\n            revert NotRegistered(subscription);\\n        }\\n        if (subscriptionRegistration != subscription) {\\n            revert CannotSubscribeToRegistrantWithSubscription(subscription);\\n        }\\n\\n        _registrations[registrant] = subscription;\\n        _subscribers[subscription].add(registrant);\\n        emit RegistrationUpdated(registrant, true);\\n        emit SubscriptionUpdated(registrant, subscription, true);\\n    }\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy)\\n        external\\n        onlyAddressOrOwner(registrant)\\n    {\\n        if (registrantToCopy == registrant) {\\n            revert CannotCopyFromSelf();\\n        }\\n        address registration = _registrations[registrant];\\n        if (registration != address(0)) {\\n            revert AlreadyRegistered();\\n        }\\n        address registrantRegistration = _registrations[registrantToCopy];\\n        if (registrantRegistration == address(0)) {\\n            revert NotRegistered(registrantToCopy);\\n        }\\n        _registrations[registrant] = registrant;\\n        emit RegistrationUpdated(registrant, true);\\n        _copyEntries(registrant, registrantToCopy);\\n    }\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered)\\n        external\\n        onlyAddressOrOwner(registrant)\\n    {\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration != registrant) {\\n            revert CannotUpdateWhileSubscribed(registration);\\n        }\\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrant];\\n\\n        if (!filtered) {\\n            bool removed = filteredOperatorsRef.remove(operator);\\n            if (!removed) {\\n                revert AddressNotFiltered(operator);\\n            }\\n        } else {\\n            bool added = filteredOperatorsRef.add(operator);\\n            if (!added) {\\n                revert AddressAlreadyFiltered(operator);\\n            }\\n        }\\n        emit OperatorUpdated(registrant, operator, filtered);\\n    }\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codeHash, bool filtered)\\n        external\\n        onlyAddressOrOwner(registrant)\\n    {\\n        if (codeHash == EOA_CODEHASH) {\\n            revert CannotFilterEOAs();\\n        }\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration != registrant) {\\n            revert CannotUpdateWhileSubscribed(registration);\\n        }\\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrant];\\n\\n        if (!filtered) {\\n            bool removed = filteredCodeHashesRef.remove(codeHash);\\n            if (!removed) {\\n                revert CodeHashNotFiltered(codeHash);\\n            }\\n        } else {\\n            bool added = filteredCodeHashesRef.add(codeHash);\\n            if (!added) {\\n                revert CodeHashAlreadyFiltered(codeHash);\\n            }\\n        }\\n        emit CodeHashUpdated(registrant, codeHash, filtered);\\n    }\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered)\\n        external\\n        onlyAddressOrOwner(registrant)\\n    {\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration != registrant) {\\n            revert CannotUpdateWhileSubscribed(registration);\\n        }\\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrant];\\n        uint256 operatorsLength = operators.length;\\n        unchecked {\\n            if (!filtered) {\\n                for (uint256 i = 0; i < operatorsLength; ++i) {\\n                    address operator = operators[i];\\n                    bool removed = filteredOperatorsRef.remove(operator);\\n                    if (!removed) {\\n                        revert AddressNotFiltered(operator);\\n                    }\\n                }\\n            } else {\\n                for (uint256 i = 0; i < operatorsLength; ++i) {\\n                    address operator = operators[i];\\n                    bool added = filteredOperatorsRef.add(operator);\\n                    if (!added) {\\n                        revert AddressAlreadyFiltered(operator);\\n                    }\\n                }\\n            }\\n        }\\n        emit OperatorsUpdated(registrant, operators, filtered);\\n    }\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered)\\n        external\\n        onlyAddressOrOwner(registrant)\\n    {\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration != registrant) {\\n            revert CannotUpdateWhileSubscribed(registration);\\n        }\\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrant];\\n        uint256 codeHashesLength = codeHashes.length;\\n        unchecked {\\n            if (!filtered) {\\n                for (uint256 i = 0; i < codeHashesLength; ++i) {\\n                    bytes32 codeHash = codeHashes[i];\\n                    bool removed = filteredCodeHashesRef.remove(codeHash);\\n                    if (!removed) {\\n                        revert CodeHashNotFiltered(codeHash);\\n                    }\\n                }\\n            } else {\\n                for (uint256 i = 0; i < codeHashesLength; ++i) {\\n                    bytes32 codeHash = codeHashes[i];\\n                    if (codeHash == EOA_CODEHASH) {\\n                        revert CannotFilterEOAs();\\n                    }\\n                    bool added = filteredCodeHashesRef.add(codeHash);\\n                    if (!added) {\\n                        revert CodeHashAlreadyFiltered(codeHash);\\n                    }\\n                }\\n            }\\n        }\\n        emit CodeHashesUpdated(registrant, codeHashes, filtered);\\n    }\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address newSubscription) external onlyAddressOrOwner(registrant) {\\n        if (registrant == newSubscription) {\\n            revert CannotSubscribeToSelf();\\n        }\\n        if (newSubscription == address(0)) {\\n            revert CannotSubscribeToZeroAddress();\\n        }\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration == newSubscription) {\\n            revert AlreadySubscribed(newSubscription);\\n        }\\n        address newSubscriptionRegistration = _registrations[newSubscription];\\n        if (newSubscriptionRegistration == address(0)) {\\n            revert NotRegistered(newSubscription);\\n        }\\n        if (newSubscriptionRegistration != newSubscription) {\\n            revert CannotSubscribeToRegistrantWithSubscription(newSubscription);\\n        }\\n\\n        if (registration != registrant) {\\n            _subscribers[registration].remove(registrant);\\n            emit SubscriptionUpdated(registrant, registration, false);\\n        }\\n        _registrations[registrant] = newSubscription;\\n        _subscribers[newSubscription].add(registrant);\\n        emit SubscriptionUpdated(registrant, newSubscription, true);\\n    }\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external onlyAddressOrOwner(registrant) {\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration == registrant) {\\n            revert NotSubscribed();\\n        }\\n        _subscribers[registration].remove(registrant);\\n        _registrations[registrant] = registrant;\\n        emit SubscriptionUpdated(registrant, registration, false);\\n        if (copyExistingEntries) {\\n            _copyEntries(registrant, registration);\\n        }\\n    }\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external onlyAddressOrOwner(registrant) {\\n        if (registrant == registrantToCopy) {\\n            revert CannotCopyFromSelf();\\n        }\\n        address registration = _registrations[registrant];\\n        if (registration == address(0)) {\\n            revert NotRegistered(registrant);\\n        }\\n        if (registration != registrant) {\\n            revert CannotUpdateWhileSubscribed(registration);\\n        }\\n        address registrantRegistration = _registrations[registrantToCopy];\\n        if (registrantRegistration == address(0)) {\\n            revert NotRegistered(registrantToCopy);\\n        }\\n        _copyEntries(registrant, registrantToCopy);\\n    }\\n\\n    /// @dev helper to copy entries from registrantToCopy to registrant and emit events\\n    function _copyEntries(address registrant, address registrantToCopy) private {\\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrantToCopy];\\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrantToCopy];\\n        uint256 filteredOperatorsLength = filteredOperatorsRef.length();\\n        uint256 filteredCodeHashesLength = filteredCodeHashesRef.length();\\n        unchecked {\\n            for (uint256 i = 0; i < filteredOperatorsLength; ++i) {\\n                address operator = filteredOperatorsRef.at(i);\\n                bool added = _filteredOperators[registrant].add(operator);\\n                if (added) {\\n                    emit OperatorUpdated(registrant, operator, true);\\n                }\\n            }\\n            for (uint256 i = 0; i < filteredCodeHashesLength; ++i) {\\n                bytes32 codehash = filteredCodeHashesRef.at(i);\\n                bool added = _filteredCodeHashes[registrant].add(codehash);\\n                if (added) {\\n                    emit CodeHashUpdated(registrant, codehash, true);\\n                }\\n            }\\n        }\\n    }\\n\\n    //////////////////\\n    // VIEW METHODS //\\n    //////////////////\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address registrant) external view returns (address subscription) {\\n        subscription = _registrations[registrant];\\n        if (subscription == address(0)) {\\n            revert NotRegistered(registrant);\\n        } else if (subscription == registrant) {\\n            subscription = address(0);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external view returns (address[] memory) {\\n        return _subscribers[registrant].values();\\n    }\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external view returns (address) {\\n        return _subscribers[registrant].at(index);\\n    }\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external view returns (bool) {\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredOperators[registration].contains(operator);\\n        }\\n        return _filteredOperators[registrant].contains(operator);\\n    }\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external view returns (bool) {\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredCodeHashes[registration].contains(codeHash);\\n        }\\n        return _filteredCodeHashes[registrant].contains(codeHash);\\n    }\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external view returns (bool) {\\n        bytes32 codeHash = operatorWithCode.codehash;\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredCodeHashes[registration].contains(codeHash);\\n        }\\n        return _filteredCodeHashes[registrant].contains(codeHash);\\n    }\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address registrant) external view returns (bool) {\\n        return _registrations[registrant] != address(0);\\n    }\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address registrant) external view returns (address[] memory) {\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredOperators[registration].values();\\n        }\\n        return _filteredOperators[registrant].values();\\n    }\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address registrant) external view returns (bytes32[] memory) {\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredCodeHashes[registration].values();\\n        }\\n        return _filteredCodeHashes[registrant].values();\\n    }\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external view returns (address) {\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredOperators[registration].at(index);\\n        }\\n        return _filteredOperators[registrant].at(index);\\n    }\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external view returns (bytes32) {\\n        address registration = _registrations[registrant];\\n        if (registration != registrant) {\\n            return _filteredCodeHashes[registration].at(index);\\n        }\\n        return _filteredCodeHashes[registrant].at(index);\\n    }\\n\\n    /// @dev Convenience method to compute the code hash of an arbitrary contract\\n    function codeHashOf(address a) external view returns (bytes32) {\\n        return a.codehash;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/OperatorFilterRegistryErrorsAndEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ncontract OperatorFilterRegistryErrorsAndEvents {\\n    error CannotFilterEOAs();\\n    error AddressAlreadyFiltered(address operator);\\n    error AddressNotFiltered(address operator);\\n    error CodeHashAlreadyFiltered(bytes32 codeHash);\\n    error CodeHashNotFiltered(bytes32 codeHash);\\n    error OnlyAddressOrOwner();\\n    error NotRegistered(address registrant);\\n    error AlreadyRegistered();\\n    error AlreadySubscribed(address subscription);\\n    error NotSubscribed();\\n    error CannotUpdateWhileSubscribed(address subscription);\\n    error CannotSubscribeToSelf();\\n    error CannotSubscribeToZeroAddress();\\n    error NotOwnable();\\n    error AddressFiltered(address filtered);\\n    error CodeHashFiltered(address account, bytes32 codeHash);\\n    error CannotSubscribeToRegistrantWithSubscription(address registrant);\\n    error CannotCopyFromSelf();\\n\\n    event RegistrationUpdated(address indexed registrant, bool indexed registered);\\n    event OperatorUpdated(address indexed registrant, address indexed operator, bool indexed filtered);\\n    event OperatorsUpdated(address indexed registrant, address[] operators, bool indexed filtered);\\n    event CodeHashUpdated(address indexed registrant, bytes32 indexed codeHash, bool indexed filtered);\\n    event CodeHashesUpdated(address indexed registrant, bytes32[] codeHashes, bool indexed filtered);\\n    event SubscriptionUpdated(address indexed registrant, address indexed subscription, bool indexed subscribed);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "0x3aebb320a0c06465c66bb0a027f6522912e14287": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SHOWDEER.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title: Showdeer\\n/// @author: manifold.xyz\\n\\nimport \\\"./ERC721Creator.sol\\\";\\n\\n////////////////////////////////////////////////////////////////////////////////////////////////\\n//                                                                                            //\\n//                                                                                            //\\n//                                                                                            //\\n//                                      ╓≈'\\\"░╬▀▀╣▓▓▓▓▓▓▓▀▄ε╓╓                                 //\\n//                               -σ∩^,░╚╙░░░,;│╙▀Θ▀╨▀▀╙╙░▄╚#▄╙╝φµ,                            //\\n//                           ╓#╠⌐,;░\\\"Γ,φ░»░,░^\\\"░░░≤░░\\\"≥╙▒╙╠╦╙╠▒[`╚░░»,,                       //\\n//                        ╔░╠╠▒φ░''  '   ' ,▒  ╘░   '.'. └\\\\╙╙ └\\\"\\\"5ε└╙φ╠▒▒ε                    //\\n//                     «▒╠▒░└└│╙~  '  '   '.▒φ,φ░     .'. '  '.. ^░φ▒ε ╙╚░▒▒╓                 //\\n//                    ░ └'   '  ''' .   ''  └╬╬▒     '  '. \\\\-- ' .]▒╠░░φ» \\\"▒░╠╦               //\\n//                 .░',    '  .      ' '' ' ]╬╬▒▒▒▒╬╬╬╬╦ \\\"\\\" '''. :\\\";░░░░░░░░φ░╠╠╦             //\\n//                ░.φ╬╬╬╣╬φ╓'         '  '   ╙╬╬╬╬╬╬╬╬╬   ' ..;░░ε`φ░░░φ░φ░░φ░╩╙ '            //\\n//              »╓╦∩╠╬╬╬╬▓▒╣'~ ...\\\"            ╠╠└└╠▒│╠∩.- ':░φ▒░╩░-░\\\"░\\\"└  '   '   .          //\\n//             .╚╠╬▒\\\"╠╬╬╬╠Åφ┌.░░¡░ .      ',▄▄▄╗╣#≥╫▄▄▒░░│░'\\\"!¡└φφ≥,.φφ,  .░-╓╔╔╓. ^╙         //\\n//           ,▒░φ╚░╓φ╬╣╓∩,Γ╚░░░░░░░'  ,▄@▀╬╝╩╢╫╬██▓▓╫╬╟╩▓▓▄.'Γ!░▒▒▒▒░╚╙░;;░φ╠╠╠╠╠╠░┌..        //\\n//           ░╚░╩╠╬╣╣╬╣╬░░╠▒░φ▒Θ░░░╓▄▓╣▒`      ╙╝▓█▀╣▀w≥╙╚▀█▄,;]╚╙░╓╔╦φφ░≥╠╠╠╠╠╠╠╠░░░░░       //\\n//          ░░░Θφ╠╬╬╬╬╬▒φ▒╠╠╩╝╣▒░▄▓╩╩╚╙@  ,╔φ▒╥>,▄▓▓▀▒▒▒▒≥╗╣╣▌░Å╠▒╠╠╠╠╠╠╠╠╠╠╠╣╬╣╣╬╠φ▒░╔φ      //\\n//         @▓╠▒╠╠╠╠φ▒╙▒░╠╠╬▒╬▒φ╬╣╩    ,╡⌂φ╬╬╩╠φ▓██▌░▒▒▒▒▒▒▒╫█▓▓▒╠╠╠╠╠╠╠╠╠╠╩▒▒╠╬╣╬╬╬╬╚╬╠╠▒     //\\n//         ╩╠╚╠╠╠╠╠╠╦╔╠╠╣╣╢╬╬╣╣▌▒╓╦▄φφ╠▀╣╣▓▒▓████▌▒▒▒▒▒▒▒▒▒╟██▓▒╠╠╠╠╠╠╠╠╠║╩▒░╙╠╩╠▒░#░░φ▒╣     //\\n//        ]▒φ▒╬▒╠╣╢╬╬╣╬╬╩▒╣╬╬╫█╬▌╚Γ╚╙▄╬╬╬╣▌╟████▒▒▒▒▒▒▒▒▒▒▄█▓█▓▓▓╢╠╠▒╠╬╬╬╬▒]╙░░╠╠╠▒░φê╠▒╚▒    //\\n//        ║╠╠╣▓╬╬╣╬╬╬╠▒╣▓╩╙╟╬▓▓╬░░.,.φ╠╬▓▓ε╟╬▓█████▓▀╫╟║█████▓██▓╣╣╬╠▒▒▒▒▒▒╠#╠▒╠╠▒░▒▒▒╣╝▒░    //\\n//        ╬╣╬╬╬╬╬╣╬╬╣╝▒╬╠╣▓▒╫▓▓▓╬▒φ╡╬▒╣╣▓█⌐ ╙╩╙╠╣▓▓▓▓█╣╚█████╬╬╬╬µ╫╙╙╙╠▒▒▒▒╠╣▒╬╣╬╬╬╚╚░░░░░    //\\n//        ╬╬╬╬╬╬╣╣╣╬╬╣╠╬╝╠▒▒▒▓▓╬╣╬╣╬╣╣▓█▀╪▒##▓▓╣████▓█╣s╙██▀█╬▀╙└└└    └╙└    ╠▓╬▄▄▄▄▄▒▓▓▓    //\\n//        ╠╬▓▓╫╣╬╬╣╬╬╬╢▄╬╚╣╬╣▓█▓╣▓▓▓▓▀╬▒╣▒╬▓╠╠▓███▓╣╬╙░░╓]╬▒└ ''    '\\\"░┐  ..  .└└'│╠╬╬▀▀▓╬    //\\n//        ╟███▓╣╬▒╚░╢╬╠█▓▒╩╩▄╬█▓▀╙└,▄╬▓█▓███████▓▓▀╣▒╫▓╣╬╫╬▄░░   ░;,.¡░  .   ..░░]▄▒▄▒░░▌▌    //\\n//        └███▓▓▓╬▒▒╚▒░░╟█▓╠╣▒╟▌▄▄▄▓█▓▓▓███▓▀███▓▓▀▓╬▓╣▄▓███▓▄░░░≡░░░░^\\\"  ;».░░▄▒▓████▓█▓Γ    //\\n//         ██╣▓▓▓▓╣▓▒φ▒▓╬╬▓▓▓▓╬▓▓╬╫╙╙╟▓▓▒  ,φ╣███████████▓▀▀▌╬▌╬╣▒║▒▄░░░░░░░╢▓█████▒╬▓▌╣╠     //\\n//          ██▓▓▓▓▓▓▓╬╠╠▒╠╬╣▓▓▓▓▓█▓▒φ╫▓██C7║▒╩▓▓██▀╠╠╠▒▓╣▀Θ╟▓╬▒╬╠▒▓█▀░▒▒░▒║▒╬▓▓▓████▓▓█▓░     //\\n//          ╙██▓▓▓▓▓▓╫▓▓▓▓╬╫╬╟╩╫╩╬╣▓█████▓⌐╚╠╪φ▒░╚▀╩╬╣╝╬╝▒▄▄╬╚▓█▒▀▓▌░░░#╠╣▓╬▓▓▓▓████╬▓▓▌      //\\n//           ╟██▓▓▓▓▓╬▓╬╬╠░░φ░▒▒φφΓ╚▒╬╣▓██╥ ╚╣╣╠╠QÇ,,]░[░⌐δ▒╟▒╚▓╬▒╫▓▓▓▓╣▓▓╣╬╣▓▓████▓▓▓▀       //\\n//            ╙▓█▓▓╟╬╣▓┐φ╠╙▒╠▒╙╚╚░░╔╙╬╠╣▓▓▓▒,╫▓╣▓▓╬╬╬╣╬╬╬▒φ⌐░░░φ▓▌╬▓▓▓█▓╣╬╬▓╣╣▓▓▓██▓▓▌        //\\n//             ╙╫╬╬╬╬╬╬φ░╬▓╠▒▒░░░░φ╙▒╫▒░▒╩╬█▓███▓█▓█▓▓▓▓▓▓▓▓▓▄░▓▓▒▓▓▓▓██▓▓▓▓╣╬▓▓▓▓██▀         //\\n//               ╠╡▒▒╠▒░▒▒φ╙╩╬▒▄░▒▒Γ░▒╠▒░░░▓██▓▓╣╬╠╠╬╣╢╩╠╠╬╣╣▄░▄▓▒▓▓▓▓▓▓▓█╬╣╬╬╬▓▓▓▓`          //\\n//                `╚╙╠╬╩╔╬╙░╠╝╚▒╬░░φ╬╠╣╣▒╬▓█▓╣▓╬▓▓▓▓▓▓╬▓╣▒▌▌╬╫░╬▓╟▓▓▓▓▓╬▓▓▓▓▓▓▓▓▓╨            //\\n//                  `╙╬▓▒▄╬╝╩Θ╙▒#╬╬╬╬╬╫╬╣▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒╬▒╠▒╠░▒░╫▓▓▓▓▓▓▓╣▓▓▓╬▓╨              //\\n//                     ╚╣╬▒▄╬╬╣╣╣╬╬╬╬╬▒╠▒╬▓▓▒╬╠╬╬╬╠╬╬▓▓╬╬╬╬╬╬╬░╠╠░╠▀██▓▓▓╣▓▓▓╙                //\\n//                       ⁿ╢╫╬╬╬╫╫╣▓▓╬▓▓█╬╬▓▓▒╬╬╠╠╠╬╣▒█▌╣╬╬╬╬╣╬░╠╬╣║▒╚╟╬▓▓▓╩└                  //\\n//                          ╙╣╣╫╩╠╬╬╬╬██▓╬╣▓φ╣╣▒▒φ╠╬▒╬╣╣╬╬╬╬╠║╬▒░╫╬╬φ╫▓╨└                     //\\n//                              ╙╩╣▓▓▓▓╣▓▓╬█▒╢▓▒╟╠▒╬╬▓╬╬▒╬╬╣╬╬╬╬╬░╝╙                          //\\n//                                  └╙▀▀╩╠▒░╬╬╬╣╬╣╣╣▀╬╠╫▓▓╬╬╝╜╙└                              //\\n//                                                                                            //\\n//    ---                                                                                     //\\n//    asciiart.club                                                                           //\\n//                                                                                            //\\n//                                                                                            //\\n//                                                                                            //\\n////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n\\ncontract SHOWDEER is ERC721Creator {\\n    constructor() ERC721Creator(\\\"Showdeer\\\", \\\"SHOWDEER\\\") {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721Creator.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\ncontract ERC721Creator is Proxy {\\n    \\n    constructor(string memory name, string memory symbol) {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = 0xe4E4003afE3765Aca8149a82fc064C0b125B9e5a;\\n        Address.functionDelegateCall(\\n            0xe4E4003afE3765Aca8149a82fc064C0b125B9e5a,\\n            abi.encodeWithSignature(\\\"initialize(string,string)\\\", name, symbol)\\n        );\\n    }\\n        \\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n     function implementation() public view returns (address) {\\n        return _implementation();\\n    }\\n\\n    function _implementation() internal override view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }    \\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "0xe4e4003afe3765aca8149a82fc064c0b125b9e5a": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport \\\"../extensions/ICreatorExtensionTokenURI.sol\\\";\\n\\nimport \\\"./ICreatorCore.sol\\\";\\n\\n/**\\n * @dev Core creator implementation\\n */\\nabstract contract CreatorCore is ReentrancyGuard, ICreatorCore, ERC165 {\\n    using Strings for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using AddressUpgradeable for address;\\n\\n    uint256 _tokenCount = 0;\\n\\n    // Track registered extensions data\\n    EnumerableSet.AddressSet internal _extensions;\\n    EnumerableSet.AddressSet internal _blacklistedExtensions;\\n    mapping (address => address) internal _extensionPermissions;\\n    mapping (address => bool) internal _extensionApproveTransfers;\\n    \\n    // For tracking which extension a token was minted by\\n    mapping (uint256 => address) internal _tokensExtension;\\n\\n    // The baseURI for a given extension\\n    mapping (address => string) private _extensionBaseURI;\\n    mapping (address => bool) private _extensionBaseURIIdentical;\\n\\n    // The prefix for any tokens with a uri configured\\n    mapping (address => string) private _extensionURIPrefix;\\n\\n    // Mapping for individual token URIs\\n    mapping (uint256 => string) internal _tokenURIs;\\n\\n    \\n    // Royalty configurations\\n    mapping (address => address payable[]) internal _extensionRoyaltyReceivers;\\n    mapping (address => uint256[]) internal _extensionRoyaltyBPS;\\n    mapping (uint256 => address payable[]) internal _tokenRoyaltyReceivers;\\n    mapping (uint256 => uint256[]) internal _tokenRoyaltyBPS;\\n\\n    /**\\n     * External interface identifiers for royalties\\n     */\\n\\n    /**\\n     *  @dev CreatorCore\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_CREATORCORE = 0xbb3bafd6;\\n\\n    /**\\n     *  @dev Rarible: RoyaltiesV1\\n     *\\n     *  bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *  bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     *\\n     *  => 0xb9c4d9fb ^ 0x0ebd4c7f = 0xb7799584\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_RARIBLE = 0xb7799584;\\n\\n    /**\\n     *  @dev Foundation\\n     *\\n     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\\n     *\\n     *  => 0xd5a06d4c = 0xd5a06d4c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_FOUNDATION = 0xd5a06d4c;\\n\\n    /**\\n     *  @dev EIP-2981\\n     *\\n     * bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n     *\\n     * => 0x2a55205a = 0x2a55205a\\n     */\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES_EIP2981 = 0x2a55205a;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(ICreatorCore).interfaceId || super.supportsInterface(interfaceId)\\n            || interfaceId == _INTERFACE_ID_ROYALTIES_CREATORCORE || interfaceId == _INTERFACE_ID_ROYALTIES_RARIBLE\\n            || interfaceId == _INTERFACE_ID_ROYALTIES_FOUNDATION || interfaceId == _INTERFACE_ID_ROYALTIES_EIP2981;\\n    }\\n\\n    /**\\n     * @dev Only allows registered extensions to call the specified function\\n     */\\n    modifier extensionRequired() {\\n        require(_extensions.contains(msg.sender), \\\"Must be registered extension\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Only allows non-blacklisted extensions\\n     */\\n    modifier nonBlacklistRequired(address extension) {\\n        require(!_blacklistedExtensions.contains(extension), \\\"Extension blacklisted\\\");\\n        _;\\n    }   \\n\\n    /**\\n     * @dev See {ICreatorCore-getExtensions}.\\n     */\\n    function getExtensions() external view override returns (address[] memory extensions) {\\n        extensions = new address[](_extensions.length());\\n        for (uint i = 0; i < _extensions.length(); i++) {\\n            extensions[i] = _extensions.at(i);\\n        }\\n        return extensions;\\n    }\\n\\n    /**\\n     * @dev Register an extension\\n     */\\n    function _registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) internal {\\n        require(extension != address(this), \\\"Creator: Invalid\\\");\\n        require(extension.isContract(), \\\"Creator: Extension must be a contract\\\");\\n        if (!_extensions.contains(extension)) {\\n            _extensionBaseURI[extension] = baseURI;\\n            _extensionBaseURIIdentical[extension] = baseURIIdentical;\\n            emit ExtensionRegistered(extension, msg.sender);\\n            _extensions.add(extension);\\n        }\\n    }\\n\\n    /**\\n     * @dev Unregister an extension\\n     */\\n    function _unregisterExtension(address extension) internal {\\n       if (_extensions.contains(extension)) {\\n           emit ExtensionUnregistered(extension, msg.sender);\\n           _extensions.remove(extension);\\n       }\\n    }\\n\\n    /**\\n     * @dev Blacklist an extension\\n     */\\n    function _blacklistExtension(address extension) internal {\\n       require(extension != address(this), \\\"Cannot blacklist yourself\\\");\\n       if (_extensions.contains(extension)) {\\n           emit ExtensionUnregistered(extension, msg.sender);\\n           _extensions.remove(extension);\\n       }\\n       if (!_blacklistedExtensions.contains(extension)) {\\n           emit ExtensionBlacklisted(extension, msg.sender);\\n           _blacklistedExtensions.add(extension);\\n       }\\n    }\\n\\n    /**\\n     * @dev Set base token uri for an extension\\n     */\\n    function _setBaseTokenURIExtension(string calldata uri, bool identical) internal {\\n        _extensionBaseURI[msg.sender] = uri;\\n        _extensionBaseURIIdentical[msg.sender] = identical;\\n    }\\n\\n    /**\\n     * @dev Set token uri prefix for an extension\\n     */\\n    function _setTokenURIPrefixExtension(string calldata prefix) internal {\\n        _extensionURIPrefix[msg.sender] = prefix;\\n    }\\n\\n    /**\\n     * @dev Set token uri for a token of an extension\\n     */\\n    function _setTokenURIExtension(uint256 tokenId, string calldata uri) internal {\\n        require(_tokensExtension[tokenId] == msg.sender, \\\"Invalid token\\\");\\n        _tokenURIs[tokenId] = uri;\\n    }\\n\\n    /**\\n     * @dev Set base token uri for tokens with no extension\\n     */\\n    function _setBaseTokenURI(string memory uri) internal {\\n        _extensionBaseURI[address(this)] = uri;\\n    }\\n\\n    /**\\n     * @dev Set token uri prefix for tokens with no extension\\n     */\\n    function _setTokenURIPrefix(string calldata prefix) internal {\\n        _extensionURIPrefix[address(this)] = prefix;\\n    }\\n\\n\\n    /**\\n     * @dev Set token uri for a token with no extension\\n     */\\n    function _setTokenURI(uint256 tokenId, string calldata uri) internal {\\n        require(_tokensExtension[tokenId] == address(this), \\\"Invalid token\\\");\\n        _tokenURIs[tokenId] = uri;\\n    }\\n\\n    /**\\n     * @dev Retrieve a token's URI\\n     */\\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\\n        address extension = _tokensExtension[tokenId];\\n        require(!_blacklistedExtensions.contains(extension), \\\"Extension blacklisted\\\");\\n\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            if (bytes(_extensionURIPrefix[extension]).length != 0) {\\n                return string(abi.encodePacked(_extensionURIPrefix[extension],_tokenURIs[tokenId]));\\n            }\\n            return _tokenURIs[tokenId];\\n        }\\n\\n        if (ERC165Checker.supportsInterface(extension, type(ICreatorExtensionTokenURI).interfaceId)) {\\n            return ICreatorExtensionTokenURI(extension).tokenURI(address(this), tokenId);\\n        }\\n\\n        if (!_extensionBaseURIIdentical[extension]) {\\n            return string(abi.encodePacked(_extensionBaseURI[extension], tokenId.toString()));\\n        } else {\\n            return _extensionBaseURI[extension];\\n        }\\n    }\\n\\n    /**\\n     * Get token extension\\n     */\\n    function _tokenExtension(uint256 tokenId) internal view returns (address extension) {\\n        extension = _tokensExtension[tokenId];\\n\\n        require(extension != address(this), \\\"No extension for token\\\");\\n        require(!_blacklistedExtensions.contains(extension), \\\"Extension blacklisted\\\");\\n\\n        return extension;\\n    }\\n\\n    /**\\n     * Helper to get royalties for a token\\n     */\\n    function _getRoyalties(uint256 tokenId) view internal returns (address payable[] storage, uint256[] storage) {\\n        return (_getRoyaltyReceivers(tokenId), _getRoyaltyBPS(tokenId));\\n    }\\n\\n    /**\\n     * Helper to get royalty receivers for a token\\n     */\\n    function _getRoyaltyReceivers(uint256 tokenId) view internal returns (address payable[] storage) {\\n        if (_tokenRoyaltyReceivers[tokenId].length > 0) {\\n            return _tokenRoyaltyReceivers[tokenId];\\n        } else if (_extensionRoyaltyReceivers[_tokensExtension[tokenId]].length > 0) {\\n            return _extensionRoyaltyReceivers[_tokensExtension[tokenId]];\\n        }\\n        return _extensionRoyaltyReceivers[address(this)];        \\n    }\\n\\n    /**\\n     * Helper to get royalty basis points for a token\\n     */\\n    function _getRoyaltyBPS(uint256 tokenId) view internal returns (uint256[] storage) {\\n        if (_tokenRoyaltyBPS[tokenId].length > 0) {\\n            return _tokenRoyaltyBPS[tokenId];\\n        } else if (_extensionRoyaltyBPS[_tokensExtension[tokenId]].length > 0) {\\n            return _extensionRoyaltyBPS[_tokensExtension[tokenId]];\\n        }\\n        return _extensionRoyaltyBPS[address(this)];        \\n    }\\n\\n    function _getRoyaltyInfo(uint256 tokenId, uint256 value) view internal returns (address receiver, uint256 amount){\\n        address payable[] storage receivers = _getRoyaltyReceivers(tokenId);\\n        require(receivers.length <= 1, \\\"More than 1 royalty receiver\\\");\\n        \\n        if (receivers.length == 0) {\\n            return (address(this), 0);\\n        }\\n        return (receivers[0], _getRoyaltyBPS(tokenId)[0]*value/10000);\\n    }\\n\\n    /**\\n     * Set royalties for a token\\n     */\\n    function _setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) internal {\\n        require(receivers.length == basisPoints.length, \\\"Invalid input\\\");\\n        uint256 totalBasisPoints;\\n        for (uint i = 0; i < basisPoints.length; i++) {\\n            totalBasisPoints += basisPoints[i];\\n        }\\n        require(totalBasisPoints < 10000, \\\"Invalid total royalties\\\");\\n        _tokenRoyaltyReceivers[tokenId] = receivers;\\n        _tokenRoyaltyBPS[tokenId] = basisPoints;\\n        emit RoyaltiesUpdated(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * Set royalties for all tokens of an extension\\n     */\\n    function _setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) internal {\\n        require(receivers.length == basisPoints.length, \\\"Invalid input\\\");\\n        uint256 totalBasisPoints;\\n        for (uint i = 0; i < basisPoints.length; i++) {\\n            totalBasisPoints += basisPoints[i];\\n        }\\n        require(totalBasisPoints < 10000, \\\"Invalid total royalties\\\");\\n        _extensionRoyaltyReceivers[extension] = receivers;\\n        _extensionRoyaltyBPS[extension] = basisPoints;\\n        if (extension == address(this)) {\\n            emit DefaultRoyaltiesUpdated(receivers, basisPoints);\\n        } else {\\n            emit ExtensionRoyaltiesUpdated(extension, receivers, basisPoints);\\n        }\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165(account).supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ICreatorExtensionTokenURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Implement this if you want your extension to have overloadable URI's\\n */\\ninterface ICreatorExtensionTokenURI is IERC165 {\\n\\n    /**\\n     * Get the uri for a given creator/tokenId\\n     */\\n    function tokenURI(address creator, uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/ICreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Core creator interface\\n */\\ninterface ICreatorCore is IERC165 {\\n\\n    event ExtensionRegistered(address indexed extension, address indexed sender);\\n    event ExtensionUnregistered(address indexed extension, address indexed sender);\\n    event ExtensionBlacklisted(address indexed extension, address indexed sender);\\n    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);\\n    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);\\n    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);\\n    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);\\n    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);\\n\\n    /**\\n     * @dev gets address of all extensions\\n     */\\n    function getExtensions() external view returns (address[] memory);\\n\\n    /**\\n     * @dev add an extension.  Can only be called by contract owner or admin.\\n     * extension address must point to a contract implementing ICreatorExtension.\\n     * Returns True if newly added, False if already added.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external;\\n\\n    /**\\n     * @dev add an extension.  Can only be called by contract owner or admin.\\n     * extension address must point to a contract implementing ICreatorExtension.\\n     * Returns True if newly added, False if already added.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;\\n\\n    /**\\n     * @dev add an extension.  Can only be called by contract owner or admin.\\n     * Returns True if removed, False if already removed.\\n     */\\n    function unregisterExtension(address extension) external;\\n\\n    /**\\n     * @dev blacklist an extension.  Can only be called by contract owner or admin.\\n     * This function will destroy all ability to reference the metadata of any tokens created\\n     * by the specified extension. It will also unregister the extension if needed.\\n     * Returns True if removed, False if already removed.\\n     */\\n    function blacklistExtension(address extension) external;\\n\\n    /**\\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri) external;\\n\\n    /**\\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\\n     * For tokens with no uri configured, tokenURI will return \\\"uri+tokenId\\\"\\n     */\\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external;\\n\\n    /**\\n     * @dev set the common prefix of an extension.  Can only be called by extension.\\n     * If configured, and a token has a uri set, tokenURI will return \\\"prefixURI+tokenURI\\\"\\n     * Useful if you want to use ipfs/arweave\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;\\n\\n    /**\\n     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\\n     * For tokens with no uri configured, tokenURI will return \\\"uri+tokenId\\\"\\n     */\\n    function setBaseTokenURI(string calldata uri) external;\\n\\n    /**\\n     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\\n     * If configured, and a token has a uri set, tokenURI will return \\\"prefixURI+tokenURI\\\"\\n     * Useful if you want to use ipfs/arweave\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri) external;\\n\\n    /**\\n     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;\\n\\n    /**\\n     * @dev set a permissions contract for an extension.  Used to control minting.\\n     */\\n    function setMintPermissions(address extension, address permissions) external;\\n\\n    /**\\n     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\\n     * from the extension before transferring\\n     */\\n    function setApproveTransferExtension(bool enabled) external;\\n\\n    /**\\n     * @dev get the extension of a given token\\n     */\\n    function tokenExtension(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Set default royalties\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;\\n\\n    /**\\n     * @dev Set royalties of a token\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\\n\\n    /**\\n     * @dev Set royalties of an extension\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\\n\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     */\\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\n    \\n    // Royalty support for various other standards\\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\\n    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/core/ERC721CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"../extensions/ERC721/IERC721CreatorExtensionApproveTransfer.sol\\\";\\nimport \\\"../extensions/ERC721/IERC721CreatorExtensionBurnable.sol\\\";\\nimport \\\"../permissions/ERC721/IERC721CreatorMintPermissions.sol\\\";\\nimport \\\"./IERC721CreatorCore.sol\\\";\\nimport \\\"./CreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC721 creator implementation\\n */\\nabstract contract ERC721CreatorCore is CreatorCore, IERC721CreatorCore {\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorCore, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721CreatorCore).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setApproveTransferExtension}.\\n     */\\n    function setApproveTransferExtension(bool enabled) external override extensionRequired {\\n        require(!enabled || ERC165Checker.supportsInterface(msg.sender, type(IERC721CreatorExtensionApproveTransfer).interfaceId), \\\"Extension must implement IERC721CreatorExtensionApproveTransfer\\\");\\n        if (_extensionApproveTransfers[msg.sender] != enabled) {\\n            _extensionApproveTransfers[msg.sender] = enabled;\\n            emit ExtensionApproveTransferUpdated(msg.sender, enabled);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set mint permissions for an extension\\n     */\\n    function _setMintPermissions(address extension, address permissions) internal {\\n        require(_extensions.contains(extension), \\\"CreatorCore: Invalid extension\\\");\\n        require(permissions == address(0x0) || ERC165Checker.supportsInterface(permissions, type(IERC721CreatorMintPermissions).interfaceId), \\\"Invalid address\\\");\\n        if (_extensionPermissions[extension] != permissions) {\\n            _extensionPermissions[extension] = permissions;\\n            emit MintPermissionsUpdated(extension, permissions, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * Check if an extension can mint\\n     */\\n    function _checkMintPermissions(address to, uint256 tokenId) internal {\\n        if (_extensionPermissions[msg.sender] != address(0x0)) {\\n            IERC721CreatorMintPermissions(_extensionPermissions[msg.sender]).approveMint(msg.sender, to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * Override for post mint actions\\n     */\\n    function _postMintBase(address, uint256) internal virtual {}\\n\\n    \\n    /**\\n     * Override for post mint actions\\n     */\\n    function _postMintExtension(address, uint256) internal virtual {}\\n\\n    /**\\n     * Post-burning callback and metadata cleanup\\n     */\\n    function _postBurn(address owner, uint256 tokenId) internal virtual {\\n        // Callback to originating extension if needed\\n        if (_tokensExtension[tokenId] != address(this)) {\\n           if (ERC165Checker.supportsInterface(_tokensExtension[tokenId], type(IERC721CreatorExtensionBurnable).interfaceId)) {\\n               IERC721CreatorExtensionBurnable(_tokensExtension[tokenId]).onBurn(owner, tokenId);\\n           }\\n        }\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }    \\n        // Delete token origin extension tracking\\n        delete _tokensExtension[tokenId];    \\n    }\\n\\n    /**\\n     * Approve a transfer\\n     */\\n    function _approveTransfer(address from, address to, uint256 tokenId) internal {\\n       if (_extensionApproveTransfers[_tokensExtension[tokenId]]) {\\n           require(IERC721CreatorExtensionApproveTransfer(_tokensExtension[tokenId]).approveTransfer(from, to, tokenId), \\\"ERC721Creator: Extension approval failure\\\");\\n       }\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC721/IERC721CreatorExtensionApproveTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * Implement this if you want your extension to approve a transfer\\n */\\ninterface IERC721CreatorExtensionApproveTransfer is IERC165 {\\n\\n    /**\\n     * @dev Set whether or not the creator will check the extension for approval of token transfer\\n     */\\n    function setApproveTransfer(address creator, bool enabled) external;\\n\\n    /**\\n     * @dev Called by creator contract to approve a transfer\\n     */\\n    function approveTransfer(address from, address to, uint256 tokenId) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ERC721/IERC721CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Your extension is required to implement this interface if it wishes\\n * to receive the onBurn callback whenever a token the extension created is\\n * burned\\n */\\ninterface IERC721CreatorExtensionBurnable is IERC165 {\\n    /**\\n     * @dev callback handler for burn events\\n     */\\n    function onBurn(address owner, uint256 tokenId) external;\\n}\"\r\n    },\r\n    \"contracts/permissions/ERC721/IERC721CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721Creator compliant extension contracts.\\n */\\ninterface IERC721CreatorMintPermissions is IERC165 {\\n\\n    /**\\n     * @dev get approval to mint\\n     */\\n    function approveMint(address extension, address to, uint256 tokenId) external;\\n}\"\r\n    },\r\n    \"contracts/core/IERC721CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"./ICreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC721 creator interface\\n */\\ninterface IERC721CreatorCore is ICreatorCore {\\n\\n    /**\\n     * @dev mint a token with no extension. Can only be called by an admin.\\n     * Returns tokenId minted\\n     */\\n    function mintBase(address to) external returns (uint256);\\n\\n    /**\\n     * @dev mint a token with no extension. Can only be called by an admin.\\n     * Returns tokenId minted\\n     */\\n    function mintBase(address to, string calldata uri) external returns (uint256);\\n\\n    /**\\n     * @dev batch mint a token with no extension. Can only be called by an admin.\\n     * Returns tokenId minted\\n     */\\n    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev batch mint a token with no extension. Can only be called by an admin.\\n     * Returns tokenId minted\\n     */\\n    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev mint a token. Can only be called by a registered extension.\\n     * Returns tokenId minted\\n     */\\n    function mintExtension(address to) external returns (uint256);\\n\\n    /**\\n     * @dev mint a token. Can only be called by a registered extension.\\n     * Returns tokenId minted\\n     */\\n    function mintExtension(address to, string calldata uri) external returns (uint256);\\n\\n    /**\\n     * @dev batch mint a token. Can only be called by a registered extension.\\n     * Returns tokenIds minted\\n     */\\n    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev batch mint a token. Can only be called by a registered extension.\\n     * Returns tokenId minted\\n     */\\n    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev burn a token. Can only be called by token owner or approved address.\\n     * On burn, calls back to the registered extension's onBurn method\\n     */\\n    function burn(uint256 tokenId) external;\\n\\n}\"\r\n    },\r\n    \"contracts/ERC721CreatorUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\\\";\\n\\nimport \\\"./core/ERC721CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC721Creator implementation (using transparent upgradeable proxy)\\n */\\ncontract ERC721CreatorUpgradeable is AdminControlUpgradeable, ERC721Upgradeable, ERC721CreatorCore {\\n\\n    /**\\n     * Initializer\\n     */\\n    function initialize(string memory _name, string memory _symbol) public initializer {\\n        __ERC721_init(_name, _symbol);\\n        __Ownable_init();\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC721CreatorCore, AdminControlUpgradeable) returns (bool) {\\n        return ERC721CreatorCore.supportsInterface(interfaceId) || ERC721Upgradeable.supportsInterface(interfaceId) || AdminControlUpgradeable.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n        _approveTransfer(from, to, tokenId);    \\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override extensionRequired {\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external override extensionRequired {\\n        _setTokenURIExtension(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override extensionRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri) external override adminRequired {\\n        _setBaseTokenURI(uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri) external override adminRequired {\\n        _setTokenURI(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURI(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBase}.\\n     */\\n    function mintBase(address to) public virtual override nonReentrant adminRequired returns(uint256) {\\n        return _mintBase(to, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBase}.\\n     */\\n    function mintBase(address to, string calldata uri) public virtual override nonReentrant adminRequired returns(uint256) {\\n        return _mintBase(to, uri);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBaseBatch}.\\n     */\\n    function mintBaseBatch(address to, uint16 count) public virtual override nonReentrant adminRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](count);\\n        for (uint16 i = 0; i < count; i++) {\\n            tokenIds[i] = _mintBase(to, \\\"\\\");\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBaseBatch}.\\n     */\\n    function mintBaseBatch(address to, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](uris.length);\\n        for (uint i = 0; i < uris.length; i++) {\\n            tokenIds[i] = _mintBase(to, uris[i]);\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Mint token with no extension\\n     */\\n    function _mintBase(address to, string memory uri) internal virtual returns(uint256 tokenId) {\\n        _tokenCount++;\\n        tokenId = _tokenCount;\\n\\n        // Track the extension that minted the token\\n        _tokensExtension[tokenId] = address(this);\\n\\n        _safeMint(to, tokenId);\\n\\n        if (bytes(uri).length > 0) {\\n            _tokenURIs[tokenId] = uri;\\n        }\\n\\n        // Call post mint\\n        _postMintBase(to, tokenId);\\n        return tokenId;\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtension}.\\n     */\\n    function mintExtension(address to) public virtual override nonReentrant extensionRequired returns(uint256) {\\n        return _mintExtension(to, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtension}.\\n     */\\n    function mintExtension(address to, string calldata uri) public virtual override nonReentrant extensionRequired returns(uint256) {\\n        return _mintExtension(to, uri);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtensionBatch}.\\n     */\\n    function mintExtensionBatch(address to, uint16 count) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](count);\\n        for (uint16 i = 0; i < count; i++) {\\n            tokenIds[i] = _mintExtension(to, \\\"\\\");\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtensionBatch}.\\n     */\\n    function mintExtensionBatch(address to, string[] calldata uris) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](uris.length);\\n        for (uint i = 0; i < uris.length; i++) {\\n            tokenIds[i] = _mintExtension(to, uris[i]);\\n        }\\n    }\\n    \\n    /**\\n     * @dev Mint token via extension\\n     */\\n    function _mintExtension(address to, string memory uri) internal virtual returns(uint256 tokenId) {\\n        _tokenCount++;\\n        tokenId = _tokenCount;\\n\\n        _checkMintPermissions(to, tokenId);\\n\\n        // Track the extension that minted the token\\n        _tokensExtension[tokenId] = msg.sender;\\n\\n        _safeMint(to, tokenId);\\n\\n        if (bytes(uri).length > 0) {\\n            _tokenURIs[tokenId] = uri;\\n        }\\n        \\n        // Call post mint\\n        _postMintExtension(to, tokenId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-burn}.\\n     */\\n    function burn(uint256 tokenId) public virtual override nonReentrant {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"Caller is not owner nor approved\\\");\\n        address owner = ownerOf(tokenId);\\n        _burn(tokenId);\\n        _postBurn(owner, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(this), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev {See ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _tokenURI(tokenId);\\n    }\\n    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./IAdminControl.sol\\\";\\n\\nabstract contract AdminControlUpgradeable is OwnableUpgradeable, IAdminControl, ERC165 {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Track registered admins\\n    EnumerableSet.AddressSet private _admins;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IAdminControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Only allows approved admins to call the specified function\\n     */\\n    modifier adminRequired() {\\n        require(owner() == msg.sender || _admins.contains(msg.sender), \\\"AdminControl: Must be owner or admin\\\");\\n        _;\\n    }   \\n\\n    /**\\n     * @dev See {IAdminControl-getAdmins}.\\n     */\\n    function getAdmins() external view override returns (address[] memory admins) {\\n        admins = new address[](_admins.length());\\n        for (uint i = 0; i < _admins.length(); i++) {\\n            admins[i] = _admins.at(i);\\n        }\\n        return admins;\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-approveAdmin}.\\n     */\\n    function approveAdmin(address admin) external override onlyOwner {\\n        if (!_admins.contains(admin)) {\\n            emit AdminApproved(admin, msg.sender);\\n            _admins.add(admin);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-revokeAdmin}.\\n     */\\n    function revokeAdmin(address admin) external override onlyOwner {\\n        if (_admins.contains(admin)) {\\n            emit AdminRevoked(admin, msg.sender);\\n            _admins.remove(admin);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-isAdmin}.\\n     */\\n    function isAdmin(address admin) public override view returns (bool) {\\n        return (owner() == admin || _admins.contains(admin));\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for admin control\\n */\\ninterface IAdminControl is IERC165 {\\n\\n    event AdminApproved(address indexed account, address indexed sender);\\n    event AdminRevoked(address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev gets address of all admins\\n     */\\n    function getAdmins() external view returns (address[] memory);\\n\\n    /**\\n     * @dev add an admin.  Can only be called by contract owner.\\n     */\\n    function approveAdmin(address admin) external;\\n\\n    /**\\n     * @dev remove an admin.  Can only be called by contract owner.\\n     */\\n    function revokeAdmin(address admin) external;\\n\\n    /**\\n     * @dev checks whether or not given address is an admin\\n     * Returns True if they are\\n     */\\n    function isAdmin(address admin) external view returns (bool);\\n\\n}\"\r\n    },\r\n    \"contracts/ERC721CreatorImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\\\";\\n\\nimport \\\"./core/ERC721CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC721Creator implementation\\n */\\ncontract ERC721CreatorImplementation is AdminControlUpgradeable, ERC721Upgradeable, ERC721CreatorCore {\\n\\n    /**\\n     * Initializer\\n     */\\n    function initialize(string memory _name, string memory _symbol) public initializer {\\n        __ERC721_init(_name, _symbol);\\n        __Ownable_init();\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC721CreatorCore, AdminControlUpgradeable) returns (bool) {\\n        return ERC721CreatorCore.supportsInterface(interfaceId) || ERC721Upgradeable.supportsInterface(interfaceId) || AdminControlUpgradeable.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n        _approveTransfer(from, to, tokenId);    \\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override extensionRequired {\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external override extensionRequired {\\n        _setTokenURIExtension(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override extensionRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri) external override adminRequired {\\n        _setBaseTokenURI(uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri) external override adminRequired {\\n        _setTokenURI(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURI(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBase}.\\n     */\\n    function mintBase(address to) public virtual override nonReentrant adminRequired returns(uint256) {\\n        return _mintBase(to, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBase}.\\n     */\\n    function mintBase(address to, string calldata uri) public virtual override nonReentrant adminRequired returns(uint256) {\\n        return _mintBase(to, uri);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBaseBatch}.\\n     */\\n    function mintBaseBatch(address to, uint16 count) public virtual override nonReentrant adminRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](count);\\n        for (uint16 i = 0; i < count; i++) {\\n            tokenIds[i] = _mintBase(to, \\\"\\\");\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBaseBatch}.\\n     */\\n    function mintBaseBatch(address to, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](uris.length);\\n        for (uint i = 0; i < uris.length; i++) {\\n            tokenIds[i] = _mintBase(to, uris[i]);\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Mint token with no extension\\n     */\\n    function _mintBase(address to, string memory uri) internal virtual returns(uint256 tokenId) {\\n        _tokenCount++;\\n        tokenId = _tokenCount;\\n\\n        // Track the extension that minted the token\\n        _tokensExtension[tokenId] = address(this);\\n\\n        _safeMint(to, tokenId);\\n\\n        if (bytes(uri).length > 0) {\\n            _tokenURIs[tokenId] = uri;\\n        }\\n\\n        // Call post mint\\n        _postMintBase(to, tokenId);\\n        return tokenId;\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtension}.\\n     */\\n    function mintExtension(address to) public virtual override nonReentrant extensionRequired returns(uint256) {\\n        return _mintExtension(to, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtension}.\\n     */\\n    function mintExtension(address to, string calldata uri) public virtual override nonReentrant extensionRequired returns(uint256) {\\n        return _mintExtension(to, uri);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtensionBatch}.\\n     */\\n    function mintExtensionBatch(address to, uint16 count) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](count);\\n        for (uint16 i = 0; i < count; i++) {\\n            tokenIds[i] = _mintExtension(to, \\\"\\\");\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtensionBatch}.\\n     */\\n    function mintExtensionBatch(address to, string[] calldata uris) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](uris.length);\\n        for (uint i = 0; i < uris.length; i++) {\\n            tokenIds[i] = _mintExtension(to, uris[i]);\\n        }\\n    }\\n    \\n    /**\\n     * @dev Mint token via extension\\n     */\\n    function _mintExtension(address to, string memory uri) internal virtual returns(uint256 tokenId) {\\n        _tokenCount++;\\n        tokenId = _tokenCount;\\n\\n        _checkMintPermissions(to, tokenId);\\n\\n        // Track the extension that minted the token\\n        _tokensExtension[tokenId] = msg.sender;\\n\\n        _safeMint(to, tokenId);\\n\\n        if (bytes(uri).length > 0) {\\n            _tokenURIs[tokenId] = uri;\\n        }\\n        \\n        // Call post mint\\n        _postMintExtension(to, tokenId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-burn}.\\n     */\\n    function burn(uint256 tokenId) public virtual override nonReentrant {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"Caller is not owner nor approved\\\");\\n        address owner = ownerOf(tokenId);\\n        _burn(tokenId);\\n        _postBurn(owner, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(this), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev {See ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _tokenURI(tokenId);\\n    }\\n    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155Upgradeable.sol\\\";\\nimport \\\"./IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    function __ERC1155_init(string memory uri_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC1155_init_unchained(uri_);\\n    }\\n\\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][account] = accountBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n    uint256[47] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/ERC1155CreatorUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\\\";\\n\\nimport \\\"./core/ERC1155CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC1155Creator implementation (using transparent upgradeable proxy)\\n */\\ncontract ERC1155CreatorUpgradeable is AdminControlUpgradeable, ERC1155Upgradeable, ERC1155CreatorCore {\\n\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * Initializer\\n     */\\n    function initialize() public initializer {\\n        __ERC1155_init(\\\"\\\");\\n        __Ownable_init();\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155Upgradeable, ERC1155CreatorCore, AdminControlUpgradeable) returns (bool) {\\n        return ERC1155CreatorCore.supportsInterface(interfaceId) || ERC1155Upgradeable.supportsInterface(interfaceId) || AdminControlUpgradeable.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\\n        _approveTransfer(from, to, ids, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri_, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_, bool identical) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri_, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override extensionRequired {\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri_) external override extensionRequired {\\n        _setTokenURIExtension(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override extensionRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri_) external override adminRequired {\\n        _setBaseTokenURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri_) external override adminRequired {\\n        _setTokenURI(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURI(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseNew}.\\n     */\\n    function mintBaseNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory) {\\n        return _mintNew(address(this), to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseExisting}.\\n     */\\n    function mintBaseExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant adminRequired {\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == address(this), \\\"A token was created by an extension\\\");\\n        }\\n        _mintExisting(address(this), to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionNew}.\\n     */\\n    function mintExtensionNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        return _mintNew(msg.sender, to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionExisting}.\\n     */\\n    function mintExtensionExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant extensionRequired {\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == address(msg.sender), \\\"A token was not created by this extension\\\");\\n        }\\n        _mintExisting(msg.sender, to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev Mint new tokens\\n     */\\n    function _mintNew(address extension, address[] memory to, uint256[] memory amounts, string[] memory uris) internal returns(uint256[] memory tokenIds) {\\n        if (to.length > 1) {\\n            // Multiple receiver.  Give every receiver the same new token\\n            tokenIds = new uint256[](1);\\n            require(uris.length <= 1 && (amounts.length == 1 || to.length == amounts.length), \\\"Invalid input\\\");\\n        } else {\\n            // Single receiver.  Generating multiple tokens\\n            tokenIds = new uint256[](amounts.length);\\n            require(uris.length == 0 || amounts.length == uris.length, \\\"Invalid input\\\");\\n        }\\n\\n        // Assign tokenIds\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _tokenCount++;\\n            tokenIds[i] = _tokenCount;\\n            // Track the extension that minted the token\\n            _tokensExtension[_tokenCount] = extension;\\n        }\\n\\n        if (extension != address(this)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1) {\\n           // Single mint\\n           _mint(to[0], tokenIds[0], amounts[0], new bytes(0));\\n        } else if (to.length > 1) {\\n            // Multiple receivers.  Receiving the same token\\n            if (amounts.length == 1) {\\n                // Everyone receiving the same amount\\n                for (uint i = 0; i < to.length; i++) {\\n                    _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n                }\\n            } else {\\n                // Everyone receiving different amounts\\n                for (uint i = 0; i < to.length; i++) {\\n                    _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n                }\\n            }\\n        } else {\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        }\\n\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            if (i < uris.length && bytes(uris[i]).length > 0) {\\n                _tokenURIs[tokenIds[i]] = uris[i];\\n            }\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Mint existing tokens\\n     */\\n    function _mintExisting(address extension, address[] memory to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        if (extension != address(this)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1 && amounts.length == 1) {\\n             // Single mint\\n            _mint(to[0], tokenIds[0], amounts[0], new bytes(0));            \\n        } else if (to.length == 1 && tokenIds.length == amounts.length) {\\n            // Batch mint to same receiver\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        } else if (tokenIds.length == 1 && amounts.length == 1) {\\n            // Mint of the same token/token amounts to various receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n            }\\n        } else if (tokenIds.length == 1 && to.length == amounts.length) {\\n            // Mint of the same token with different amounts to different receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n            }\\n        } else if (to.length == tokenIds.length && to.length == amounts.length) {\\n            // Mint of different tokens and different amounts to different receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[i], amounts[i], new bytes(0));\\n            }\\n        } else {\\n            revert(\\\"Invalid input\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-burn}.\\n     */\\n    function burn(address account, uint256[] memory tokenIds, uint256[] memory amounts) public virtual override nonReentrant {\\n        require(account == msg.sender || isApprovedForAll(account, msg.sender), \\\"Caller is not owner nor approved\\\");\\n        require(tokenIds.length == amounts.length, \\\"Invalid input\\\");\\n        if (tokenIds.length == 1) {\\n            _burn(account, tokenIds[0], amounts[0]);\\n        } else {\\n            _burnBatch(account, tokenIds, amounts);\\n        }\\n        _postBurn(account, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(this), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev {See ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\\n        return _tokenURI(tokenId);\\n    }\\n    \\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 tokenId) external view virtual override returns (uint256) {\\n        return _totalSupply[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mint}.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual override {\\n        super._mint(account, id, amount, data);\\n        _totalSupply[id] += amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mintBatch}.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] += amounts[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burn}.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual override {\\n        super._burn(account, id, amount);\\n        _totalSupply[id] -= amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burnBatch}.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual override {\\n        super._burnBatch(account, ids, amounts);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] -= amounts[i];\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/core/ERC1155CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"../extensions/ERC1155/IERC1155CreatorExtensionApproveTransfer.sol\\\";\\nimport \\\"../extensions/ERC1155/IERC1155CreatorExtensionBurnable.sol\\\";\\nimport \\\"../permissions/ERC1155/IERC1155CreatorMintPermissions.sol\\\";\\nimport \\\"./IERC1155CreatorCore.sol\\\";\\nimport \\\"./CreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC1155 creator implementation\\n */\\nabstract contract ERC1155CreatorCore is CreatorCore, IERC1155CreatorCore {\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorCore, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155CreatorCore).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setApproveTransferExtension}.\\n     */\\n    function setApproveTransferExtension(bool enabled) external override extensionRequired {\\n        require(!enabled || ERC165Checker.supportsInterface(msg.sender, type(IERC1155CreatorExtensionApproveTransfer).interfaceId), \\\"Extension must implement IERC1155CreatorExtensionApproveTransfer\\\");\\n        if (_extensionApproveTransfers[msg.sender] != enabled) {\\n            _extensionApproveTransfers[msg.sender] = enabled;\\n            emit ExtensionApproveTransferUpdated(msg.sender, enabled);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set mint permissions for an extension\\n     */\\n    function _setMintPermissions(address extension, address permissions) internal {\\n        require(_extensions.contains(extension), \\\"Invalid extension\\\");\\n        require(permissions == address(0x0) || ERC165Checker.supportsInterface(permissions, type(IERC1155CreatorMintPermissions).interfaceId), \\\"Invalid address\\\");\\n        if (_extensionPermissions[extension] != permissions) {\\n            _extensionPermissions[extension] = permissions;\\n            emit MintPermissionsUpdated(extension, permissions, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * Check if an extension can mint\\n     */\\n    function _checkMintPermissions(address[] memory to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        if (_extensionPermissions[msg.sender] != address(0x0)) {\\n            IERC1155CreatorMintPermissions(_extensionPermissions[msg.sender]).approveMint(msg.sender, to, tokenIds, amounts);\\n        }\\n    }\\n\\n    /**\\n     * Post burn actions\\n     */\\n    function _postBurn(address owner, uint256[] memory tokenIds, uint256[] memory amounts) internal virtual {\\n        require(tokenIds.length > 0, \\\"Invalid input\\\");\\n        address extension = _tokensExtension[tokenIds[0]];\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == extension, \\\"Mismatched token originators\\\");\\n        }\\n        // Callback to originating extension if needed\\n        if (extension != address(this)) {\\n           if (ERC165Checker.supportsInterface(extension, type(IERC1155CreatorExtensionBurnable).interfaceId)) {\\n               IERC1155CreatorExtensionBurnable(extension).onBurn(owner, tokenIds, amounts);\\n           }\\n        }\\n    }\\n\\n    /**\\n     * Approve a transfer\\n     */\\n    function _approveTransfer(address from, address to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        require(tokenIds.length > 0, \\\"Invalid input\\\");\\n        address extension = _tokensExtension[tokenIds[0]];\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == extension, \\\"Mismatched token originators\\\");\\n        }\\n        if (_extensionApproveTransfers[extension]) {\\n            require(IERC1155CreatorExtensionApproveTransfer(extension).approveTransfer(from, to, tokenIds, amounts), \\\"Extension approval failure\\\");\\n        }\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC1155/IERC1155CreatorExtensionApproveTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * Implement this if you want your extension to approve a transfer\\n */\\ninterface IERC1155CreatorExtensionApproveTransfer is IERC165 {\\n\\n    /**\\n     * @dev Set whether or not the creator contract will check the extension for approval of token transfer\\n     */\\n    function setApproveTransfer(address creator, bool enabled) external;\\n\\n    /**\\n     * @dev Called by creator contract to approve a transfer\\n     */\\n    function approveTransfer(address from, address to, uint256[] calldata tokenIds, uint256[] calldata amounts) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC1155/IERC1155CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Your extension is required to implement this interface if it wishes\\n * to receive the onBurn callback whenever a token the extension created is\\n * burned\\n */\\ninterface IERC1155CreatorExtensionBurnable is IERC165 {\\n    /**\\n     * @dev callback handler for burn events\\n     */\\n    function onBurn(address owner, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n}\"\r\n    },\r\n    \"contracts/permissions/ERC1155/IERC1155CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155Creator compliant extension contracts.\\n */\\ninterface IERC1155CreatorMintPermissions is IERC165 {\\n\\n    /**\\n     * @dev get approval to mint\\n     */\\n    function approveMint(address extension, address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n}\"\r\n    },\r\n    \"contracts/core/IERC1155CreatorCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"./CreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC1155 creator interface\\n */\\ninterface IERC1155CreatorCore is ICreatorCore {\\n\\n    /**\\n     * @dev mint a token with no extension. Can only be called by an admin.\\n     *\\n     * @param to       - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param amounts  - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     * @param uris     - If no elements, all tokens use the default uri.\\n     *                   If any element is an empty string, the corresponding token uses the default uri.\\n     *\\n     *\\n     * Requirements: If to is a multi-element array, then uris must be empty or single element array\\n     *               If to is a multi-element array, then amounts must be a single element array or a multi-element array of the same size\\n     *               If to is a single element array, uris must be empty or the same length as amounts\\n     *\\n     * Examples:\\n     *    mintBaseNew(['0x....1', '0x....2'], [1], [])\\n     *        Mints a single new token, and gives 1 each to '0x....1' and '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintBaseNew(['0x....1', '0x....2'], [1, 2], [])\\n     *        Mints a single new token, and gives 1 to '0x....1' and 2 to '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintBaseNew(['0x....1'], [1, 2], [\\\"\\\", \\\"http://token2.com\\\"])\\n     *        Mints two new tokens to '0x....1'. 1 of the first token, 2 of the second.  1st token uses default uri, second uses \\\"http://token2.com\\\".\\n     *    \\n     * @return Returns list of tokenIds minted\\n     */\\n    function mintBaseNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev batch mint existing token with no extension. Can only be called by an admin.\\n     *\\n     * @param to        - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param tokenIds  - Can be a single element array (all recipients get the same token) or a multi-element array\\n     * @param amounts   - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     *\\n     * Requirements: If any of the parameters are multi-element arrays, they need to be the same length as other multi-element arrays\\n     *\\n     * Examples:\\n     *    mintBaseExisting(['0x....1', '0x....2'], [1], [10])\\n     *        Mints 10 of tokenId 1 to each of '0x....1' and '0x....2'.\\n     *    \\n     *    mintBaseExisting(['0x....1', '0x....2'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 2 to '0x....2'.\\n     *    \\n     *    mintBaseExisting(['0x....1'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 and 20 of tokenId 2 to '0x....1'.\\n     *    \\n     *    mintBaseExisting(['0x....1', '0x....2'], [1], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 1 to '0x....2'.\\n     *    \\n     */\\n    function mintBaseExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @dev mint a token from an extension. Can only be called by a registered extension.\\n     *\\n     * @param to       - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param amounts  - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     * @param uris     - If no elements, all tokens use the default uri.\\n     *                   If any element is an empty string, the corresponding token uses the default uri.\\n     *\\n     *\\n     * Requirements: If to is a multi-element array, then uris must be empty or single element array\\n     *               If to is a multi-element array, then amounts must be a single element array or a multi-element array of the same size\\n     *               If to is a single element array, uris must be empty or the same length as amounts\\n     *\\n     * Examples:\\n     *    mintExtensionNew(['0x....1', '0x....2'], [1], [])\\n     *        Mints a single new token, and gives 1 each to '0x....1' and '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintExtensionNew(['0x....1', '0x....2'], [1, 2], [])\\n     *        Mints a single new token, and gives 1 to '0x....1' and 2 to '0x....2'.  Token uses default uri.\\n     *    \\n     *    mintExtensionNew(['0x....1'], [1, 2], [\\\"\\\", \\\"http://token2.com\\\"])\\n     *        Mints two new tokens to '0x....1'. 1 of the first token, 2 of the second.  1st token uses default uri, second uses \\\"http://token2.com\\\".\\n     *    \\n     * @return Returns list of tokenIds minted\\n     */\\n    function mintExtensionNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external returns (uint256[] memory);\\n\\n    /**\\n     * @dev batch mint existing token from extension. Can only be called by a registered extension.\\n     *\\n     * @param to        - Can be a single element array (all tokens go to same address) or multi-element array (single token to many recipients)\\n     * @param tokenIds  - Can be a single element array (all recipients get the same token) or a multi-element array\\n     * @param amounts   - Can be a single element array (all recipients get the same amount) or a multi-element array\\n     *\\n     * Requirements: If any of the parameters are multi-element arrays, they need to be the same length as other multi-element arrays\\n     *\\n     * Examples:\\n     *    mintExtensionExisting(['0x....1', '0x....2'], [1], [10])\\n     *        Mints 10 of tokenId 1 to each of '0x....1' and '0x....2'.\\n     *    \\n     *    mintExtensionExisting(['0x....1', '0x....2'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 2 to '0x....2'.\\n     *    \\n     *    mintExtensionExisting(['0x....1'], [1, 2], [10, 20])\\n     *        Mints 10 of tokenId 1 and 20 of tokenId 2 to '0x....1'.\\n     *    \\n     *    mintExtensionExisting(['0x....1', '0x....2'], [1], [10, 20])\\n     *        Mints 10 of tokenId 1 to '0x....1' and 20 of tokenId 1 to '0x....2'.\\n     *    \\n     */\\n    function mintExtensionExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @dev burn tokens. Can only be called by token owner or approved address.\\n     * On burn, calls back to the registered extension's onBurn method\\n     */\\n    function burn(address account, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given tokenId.\\n     */\\n    function totalSupply(uint256 tokenId) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/ERC1155CreatorImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControlUpgradeable.sol\\\";\\n\\nimport \\\"./core/ERC1155CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC1155Creator implementation\\n */\\ncontract ERC1155CreatorImplementation is AdminControlUpgradeable, ERC1155Upgradeable, ERC1155CreatorCore {\\n\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * Initializer\\n     */\\n    function initialize() public initializer {\\n        __ERC1155_init(\\\"\\\");\\n        __Ownable_init();\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155Upgradeable, ERC1155CreatorCore, AdminControlUpgradeable) returns (bool) {\\n        return ERC1155CreatorCore.supportsInterface(interfaceId) || ERC1155Upgradeable.supportsInterface(interfaceId) || AdminControlUpgradeable.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\\n        _approveTransfer(from, to, ids, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri_, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_, bool identical) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri_, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override extensionRequired {\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri_) external override extensionRequired {\\n        _setTokenURIExtension(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override extensionRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri_) external override adminRequired {\\n        _setBaseTokenURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri_) external override adminRequired {\\n        _setTokenURI(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURI(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseNew}.\\n     */\\n    function mintBaseNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory) {\\n        return _mintNew(address(this), to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseExisting}.\\n     */\\n    function mintBaseExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant adminRequired {\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == address(this), \\\"A token was created by an extension\\\");\\n        }\\n        _mintExisting(address(this), to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionNew}.\\n     */\\n    function mintExtensionNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        return _mintNew(msg.sender, to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionExisting}.\\n     */\\n    function mintExtensionExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant extensionRequired {\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == address(msg.sender), \\\"A token was not created by this extension\\\");\\n        }\\n        _mintExisting(msg.sender, to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev Mint new tokens\\n     */\\n    function _mintNew(address extension, address[] memory to, uint256[] memory amounts, string[] memory uris) internal returns(uint256[] memory tokenIds) {\\n        if (to.length > 1) {\\n            // Multiple receiver.  Give every receiver the same new token\\n            tokenIds = new uint256[](1);\\n            require(uris.length <= 1 && (amounts.length == 1 || to.length == amounts.length), \\\"Invalid input\\\");\\n        } else {\\n            // Single receiver.  Generating multiple tokens\\n            tokenIds = new uint256[](amounts.length);\\n            require(uris.length == 0 || amounts.length == uris.length, \\\"Invalid input\\\");\\n        }\\n\\n        // Assign tokenIds\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _tokenCount++;\\n            tokenIds[i] = _tokenCount;\\n            // Track the extension that minted the token\\n            _tokensExtension[_tokenCount] = extension;\\n        }\\n\\n        if (extension != address(this)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1) {\\n           // Single mint\\n           _mint(to[0], tokenIds[0], amounts[0], new bytes(0));\\n        } else if (to.length > 1) {\\n            // Multiple receivers.  Receiving the same token\\n            if (amounts.length == 1) {\\n                // Everyone receiving the same amount\\n                for (uint i = 0; i < to.length; i++) {\\n                    _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n                }\\n            } else {\\n                // Everyone receiving different amounts\\n                for (uint i = 0; i < to.length; i++) {\\n                    _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n                }\\n            }\\n        } else {\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        }\\n\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            if (i < uris.length && bytes(uris[i]).length > 0) {\\n                _tokenURIs[tokenIds[i]] = uris[i];\\n            }\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Mint existing tokens\\n     */\\n    function _mintExisting(address extension, address[] memory to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        if (extension != address(this)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1 && amounts.length == 1) {\\n             // Single mint\\n            _mint(to[0], tokenIds[0], amounts[0], new bytes(0));            \\n        } else if (to.length == 1 && tokenIds.length == amounts.length) {\\n            // Batch mint to same receiver\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        } else if (tokenIds.length == 1 && amounts.length == 1) {\\n            // Mint of the same token/token amounts to various receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n            }\\n        } else if (tokenIds.length == 1 && to.length == amounts.length) {\\n            // Mint of the same token with different amounts to different receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n            }\\n        } else if (to.length == tokenIds.length && to.length == amounts.length) {\\n            // Mint of different tokens and different amounts to different receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[i], amounts[i], new bytes(0));\\n            }\\n        } else {\\n            revert(\\\"Invalid input\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-burn}.\\n     */\\n    function burn(address account, uint256[] memory tokenIds, uint256[] memory amounts) public virtual override nonReentrant {\\n        require(account == msg.sender || isApprovedForAll(account, msg.sender), \\\"Caller is not owner nor approved\\\");\\n        require(tokenIds.length == amounts.length, \\\"Invalid input\\\");\\n        if (tokenIds.length == 1) {\\n            _burn(account, tokenIds[0], amounts[0]);\\n        } else {\\n            _burnBatch(account, tokenIds, amounts);\\n        }\\n        _postBurn(account, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(this), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev {See ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\\n        return _tokenURI(tokenId);\\n    }\\n    \\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 tokenId) external view virtual override returns (uint256) {\\n        return _totalSupply[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mint}.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual override {\\n        super._mint(account, id, amount, data);\\n        _totalSupply[id] += amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mintBatch}.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] += amounts[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burn}.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual override {\\n        super._burn(account, id, amount);\\n        _totalSupply[id] -= amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burnBatch}.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual override {\\n        super._burnBatch(account, ids, amounts);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] -= amounts[i];\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/ERC1155Creator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\n\\nimport \\\"./core/ERC1155CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC1155Creator implementation\\n */\\ncontract ERC1155Creator is AdminControl, ERC1155, ERC1155CreatorCore {\\n\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    constructor () ERC1155(\\\"\\\") {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, ERC1155CreatorCore, AdminControl) returns (bool) {\\n        return ERC1155CreatorCore.supportsInterface(interfaceId) || ERC1155.supportsInterface(interfaceId) || AdminControl.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\\n        _approveTransfer(from, to, ids, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri_, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri_, bool identical) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri_, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override extensionRequired {\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri_) external override extensionRequired {\\n        _setTokenURIExtension(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override extensionRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri_) external override adminRequired {\\n        _setBaseTokenURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri_) external override adminRequired {\\n        _setTokenURI(tokenId, uri_);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURI(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseNew}.\\n     */\\n    function mintBaseNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory) {\\n        return _mintNew(address(this), to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintBaseExisting}.\\n     */\\n    function mintBaseExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant adminRequired {\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == address(this), \\\"A token was created by an extension\\\");\\n        }\\n        _mintExisting(address(this), to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionNew}.\\n     */\\n    function mintExtensionNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        return _mintNew(msg.sender, to, amounts, uris);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-mintExtensionExisting}.\\n     */\\n    function mintExtensionExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public virtual override nonReentrant extensionRequired {\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(_tokensExtension[tokenIds[i]] == address(msg.sender), \\\"A token was not created by this extension\\\");\\n        }\\n        _mintExisting(msg.sender, to, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev Mint new tokens\\n     */\\n    function _mintNew(address extension, address[] memory to, uint256[] memory amounts, string[] memory uris) internal returns(uint256[] memory tokenIds) {\\n        if (to.length > 1) {\\n            // Multiple receiver.  Give every receiver the same new token\\n            tokenIds = new uint256[](1);\\n            require(uris.length <= 1 && (amounts.length == 1 || to.length == amounts.length), \\\"Invalid input\\\");\\n        } else {\\n            // Single receiver.  Generating multiple tokens\\n            tokenIds = new uint256[](amounts.length);\\n            require(uris.length == 0 || amounts.length == uris.length, \\\"Invalid input\\\");\\n        }\\n\\n        // Assign tokenIds\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _tokenCount++;\\n            tokenIds[i] = _tokenCount;\\n            // Track the extension that minted the token\\n            _tokensExtension[_tokenCount] = extension;\\n        }\\n\\n        if (extension != address(this)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1) {\\n           // Single mint\\n           _mint(to[0], tokenIds[0], amounts[0], new bytes(0));\\n        } else if (to.length > 1) {\\n            // Multiple receivers.  Receiving the same token\\n            if (amounts.length == 1) {\\n                // Everyone receiving the same amount\\n                for (uint i = 0; i < to.length; i++) {\\n                    _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n                }\\n            } else {\\n                // Everyone receiving different amounts\\n                for (uint i = 0; i < to.length; i++) {\\n                    _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n                }\\n            }\\n        } else {\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        }\\n\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            if (i < uris.length && bytes(uris[i]).length > 0) {\\n                _tokenURIs[tokenIds[i]] = uris[i];\\n            }\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Mint existing tokens\\n     */\\n    function _mintExisting(address extension, address[] memory to, uint256[] memory tokenIds, uint256[] memory amounts) internal {\\n        if (extension != address(this)) {\\n            _checkMintPermissions(to, tokenIds, amounts);\\n        }\\n\\n        if (to.length == 1 && tokenIds.length == 1 && amounts.length == 1) {\\n             // Single mint\\n            _mint(to[0], tokenIds[0], amounts[0], new bytes(0));            \\n        } else if (to.length == 1 && tokenIds.length == amounts.length) {\\n            // Batch mint to same receiver\\n            _mintBatch(to[0], tokenIds, amounts, new bytes(0));\\n        } else if (tokenIds.length == 1 && amounts.length == 1) {\\n            // Mint of the same token/token amounts to various receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[0], amounts[0], new bytes(0));\\n            }\\n        } else if (tokenIds.length == 1 && to.length == amounts.length) {\\n            // Mint of the same token with different amounts to different receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[0], amounts[i], new bytes(0));\\n            }\\n        } else if (to.length == tokenIds.length && to.length == amounts.length) {\\n            // Mint of different tokens and different amounts to different receivers\\n            for (uint i = 0; i < to.length; i++) {\\n                _mint(to[i], tokenIds[i], amounts[i], new bytes(0));\\n            }\\n        } else {\\n            revert(\\\"Invalid input\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorCore-burn}.\\n     */\\n    function burn(address account, uint256[] memory tokenIds, uint256[] memory amounts) public virtual override nonReentrant {\\n        require(account == msg.sender || isApprovedForAll(account, msg.sender), \\\"Caller is not owner nor approved\\\");\\n        require(tokenIds.length == amounts.length, \\\"Invalid input\\\");\\n        if (tokenIds.length == 1) {\\n            _burn(account, tokenIds[0], amounts[0]);\\n        } else {\\n            _burnBatch(account, tokenIds, amounts);\\n        }\\n        _postBurn(account, tokenIds, amounts);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(this), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev {See ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\\n        return _tokenURI(tokenId);\\n    }\\n    \\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 tokenId) external view virtual override returns (uint256) {\\n        return _totalSupply[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mint}.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual override {\\n        super._mint(account, id, amount, data);\\n        _totalSupply[id] += amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mintBatch}.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] += amounts[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burn}.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual override {\\n        super._burn(account, id, amount);\\n        _totalSupply[id] -= amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burnBatch}.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual override {\\n        super._burnBatch(account, ids, amounts);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] -= amounts[i];\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][account] = accountBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IAdminControl.sol\\\";\\n\\nabstract contract AdminControl is Ownable, IAdminControl, ERC165 {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Track registered admins\\n    EnumerableSet.AddressSet private _admins;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IAdminControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Only allows approved admins to call the specified function\\n     */\\n    modifier adminRequired() {\\n        require(owner() == msg.sender || _admins.contains(msg.sender), \\\"AdminControl: Must be owner or admin\\\");\\n        _;\\n    }   \\n\\n    /**\\n     * @dev See {IAdminControl-getAdmins}.\\n     */\\n    function getAdmins() external view override returns (address[] memory admins) {\\n        admins = new address[](_admins.length());\\n        for (uint i = 0; i < _admins.length(); i++) {\\n            admins[i] = _admins.at(i);\\n        }\\n        return admins;\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-approveAdmin}.\\n     */\\n    function approveAdmin(address admin) external override onlyOwner {\\n        if (!_admins.contains(admin)) {\\n            emit AdminApproved(admin, msg.sender);\\n            _admins.add(admin);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-revokeAdmin}.\\n     */\\n    function revokeAdmin(address admin) external override onlyOwner {\\n        if (_admins.contains(admin)) {\\n            emit AdminRevoked(admin, msg.sender);\\n            _admins.remove(admin);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IAdminControl-isAdmin}.\\n     */\\n    function isAdmin(address admin) public override view returns (bool) {\\n        return (owner() == admin || _admins.contains(admin));\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/permissions/ERC721/ERC721CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\nimport \\\"../../core/IERC721CreatorCore.sol\\\";\\nimport \\\"./IERC721CreatorMintPermissions.sol\\\";\\n\\n/**\\n * @dev Basic implementation of a permission contract that works with a singular creator contract.\\n * approveMint requires the sender to be the configured creator.\\n */\\nabstract contract ERC721CreatorMintPermissions is ERC165, AdminControl, IERC721CreatorMintPermissions {\\n     address internal immutable _creator;\\n\\n     constructor(address creator_) {\\n         require(ERC165Checker.supportsInterface(creator_, type(IERC721CreatorCore).interfaceId), \\\"Must implement IERC721CreatorCore\\\");\\n         _creator = creator_;\\n     }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165, AdminControl) returns (bool) {\\n        return interfaceId == type(IERC721CreatorMintPermissions).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorMintPermissions-approve}.\\n     */\\n    function approveMint(address, address, uint256) public virtual override {\\n        require(msg.sender == _creator, \\\"Can only be called by token creator\\\");\\n    }\\n     \\n\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/ICreatorExtensionBasic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Provides functions to set token uri's\\n */\\ninterface ICreatorExtensionBasic is IERC165 {\\n\\n    /**\\n     * @dev set the baseTokenURI of tokens generated by this extension.  Can only be called by admins.\\n     */\\n    function setBaseTokenURI(address creator, string calldata uri) external;\\n\\n    /**\\n     * @dev set the baseTokenURI of tokens generated by this extension.  Can only be called by admins.\\n     */\\n    function setBaseTokenURI(address creator, string calldata uri, bool identical) external;\\n\\n    /**\\n     * @dev set the tokenURI of a token generated by this extension.  Can only be called by admins.\\n     */\\n    function setTokenURI(address creator, uint256 tokenId, string calldata uri) external;\\n\\n    /**\\n     * @dev set the tokenURI of multiple tokens generated by this extension.  Can only be called by admins.\\n     */\\n    function setTokenURI(address creator, uint256[] calldata tokenId, string[] calldata uri) external;\\n\\n    /**\\n     * @dev set the extension's token uri prefix\\n     */\\n    function setTokenURIPrefix(address creator, string calldata prefix) external;\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/CreatorExtensionBasic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\n\\nimport \\\"../core/ICreatorCore.sol\\\";\\nimport \\\"./ICreatorExtensionBasic.sol\\\";\\nimport \\\"./CreatorExtension.sol\\\";\\n\\n/**\\n * @dev Provides functions to set token uri's\\n */\\nabstract contract CreatorExtensionBasic is AdminControl, CreatorExtension, ICreatorExtensionBasic {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AdminControl, CreatorExtension, IERC165) returns (bool) {\\n        return interfaceId == type(ICreatorExtensionBasic).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorExtensionBasic-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(address creator, string calldata uri) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(ICreatorCore).interfaceId), \\\"Requires creator to implement ICreatorCore\\\");\\n        ICreatorCore(creator).setBaseTokenURIExtension(uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorExtensionBasic-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(address creator, string calldata uri, bool identical) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(ICreatorCore).interfaceId), \\\"Requires creator to implement CreatorCore\\\");\\n        ICreatorCore(creator).setBaseTokenURIExtension(uri, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorExtensionBasic-setTokenURI}.\\n     */\\n    function setTokenURI(address creator, uint256 tokenId, string calldata uri) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(ICreatorCore).interfaceId), \\\"Requires creator to implement CreatorCore\\\");\\n        ICreatorCore(creator).setTokenURIExtension(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorExtensionBasic-setTokenURI}.\\n     */\\n    function setTokenURI(address creator, uint256[] calldata tokenIds, string[] calldata uris) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(ICreatorCore).interfaceId), \\\"Requires creator to implement CreatorCore\\\");\\n        ICreatorCore(creator).setTokenURIExtension(tokenIds, uris);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorExtensionBasic-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(address creator, string calldata prefix) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(ICreatorCore).interfaceId), \\\"Requires creator to implement CreatorCore\\\");\\n        ICreatorCore(creator).setTokenURIPrefixExtension(prefix);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/CreatorExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Base creator extension variables\\n */\\nabstract contract CreatorExtension is ERC165 {\\n\\n    /**\\n     * @dev Legacy extension interface identifiers\\n     *\\n     * {IERC165-supportsInterface} needs to return 'true' for this interface\\n     * in order backwards compatible with older creator contracts\\n     */\\n    bytes4 constant internal LEGACY_EXTENSION_INTERFACE = 0x7005caad;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\\n        return interfaceId == LEGACY_EXTENSION_INTERFACE\\n            || super.supportsInterface(interfaceId);\\n    }\\n    \\n}\"\r\n    },\r\n    \"contracts/mocks/MockERC721CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../extensions/ERC721/ERC721CreatorExtensionBurnable.sol\\\";\\nimport \\\"../extensions/CreatorExtensionBasic.sol\\\";\\n\\ncontract MockERC721CreatorExtensionBurnable is CreatorExtensionBasic, ERC721CreatorExtensionBurnable {\\n    uint256 [] _mintedTokens;\\n    uint256 [] _burntTokens;\\n    address _creator;\\n    \\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorExtensionBasic, ERC721CreatorExtensionBurnable) returns (bool) {\\n        return CreatorExtensionBasic.supportsInterface(interfaceId) || ERC721CreatorExtensionBurnable.supportsInterface(interfaceId);\\n    }\\n\\n    constructor(address creator) {\\n        _creator = creator;\\n    }\\n\\n    function testMint(address to) external {\\n        _mintedTokens.push(_mint(_creator, to));\\n    }\\n\\n    function testMint(address to, string calldata uri) external {\\n        _mintedTokens.push(_mint(_creator, to, uri));\\n    }\\n\\n    function testMintBatch(address to, uint16 count) external {\\n        uint256[] memory tokenIds = _mintBatch(_creator, to, count);\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _mintedTokens.push(tokenIds[i]);\\n        }\\n    }\\n\\n    function testMintBatch(address to, string[] calldata uris) external {\\n        uint256[] memory tokenIds = _mintBatch(_creator, to, uris);\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _mintedTokens.push(tokenIds[i]);\\n        }\\n    }\\n\\n    function mintedTokens() external view returns(uint256[] memory) {\\n        return _mintedTokens;\\n    }\\n\\n    function burntTokens() external view returns(uint256[] memory) {\\n        return _burntTokens;\\n    }\\n\\n    function onBurn(address to, uint256 tokenId) public override {\\n        ERC721CreatorExtensionBurnable.onBurn(to, tokenId);\\n        _burntTokens.push(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ERC721/ERC721CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\n\\nimport \\\"../../core/IERC721CreatorCore.sol\\\";\\nimport \\\"./ERC721CreatorExtension.sol\\\";\\nimport \\\"./IERC721CreatorExtensionBurnable.sol\\\";\\n\\n/**\\n * @dev Suggested implementation for extensions that want to receive onBurn callbacks\\n * Mint tracks the creators/tokens created, and onBurn only accepts callbacks from\\n * the creator of a token created.\\n */\\nabstract contract ERC721CreatorExtensionBurnable is AdminControl, ERC721CreatorExtension, IERC721CreatorExtensionBurnable {\\n\\n    mapping (uint256 => address) private _tokenCreators;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AdminControl, CreatorExtension, IERC165) returns (bool) {\\n        return interfaceId == LEGACY_ERC721_EXTENSION_BURNABLE_INTERFACE\\n            || interfaceId == type(IERC721CreatorExtensionBurnable).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev mint a token\\n     */\\n    function mint(address creator, address to) external adminRequired returns (uint256) {\\n        return _mint(creator, to);\\n    }\\n\\n    /**\\n     * @dev batch mint a token\\n     */\\n    function mintBatch(address creator, address to, uint16 count) external adminRequired returns (uint256[] memory) {\\n        return _mintBatch(creator, to, count);\\n    }\\n\\n    function _mint(address creator, address to) internal returns (uint256) {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC721CreatorCore).interfaceId), \\\"creator must implement IERC721CreatorCore\\\");\\n        uint256 tokenId = IERC721CreatorCore(creator).mintExtension(to);\\n        _tokenCreators[tokenId] = creator;\\n        return tokenId;\\n    }\\n\\n    function _mint(address creator, address to, string memory uri) internal returns (uint256) {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC721CreatorCore).interfaceId), \\\"creator must implement IERC721CreatorCore\\\");\\n        uint256 tokenId = IERC721CreatorCore(creator).mintExtension(to, uri);\\n        _tokenCreators[tokenId] = creator;\\n        return tokenId;\\n    }\\n\\n    function _mintBatch(address creator, address to, uint16 count) internal returns (uint256[] memory tokenIds) {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC721CreatorCore).interfaceId), \\\"creator must implement IERC721CreatorCore\\\");\\n        tokenIds = IERC721CreatorCore(creator).mintExtensionBatch(to, count);\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            _tokenCreators[tokenIds[i]] = creator;\\n        }\\n        return tokenIds;\\n    }\\n\\n    function _mintBatch(address creator, address to, string[] memory uris) internal returns (uint256[] memory tokenIds) {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC721CreatorCore).interfaceId), \\\"creator must implement IERC721CreatorCore\\\");\\n        tokenIds = IERC721CreatorCore(creator).mintExtensionBatch(to, uris);\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            _tokenCreators[tokenIds[i]] = creator;\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorExtension-onBurn}.\\n     */\\n    function onBurn(address, uint256 tokenId) public virtual override {\\n        require(_tokenCreators[tokenId] == msg.sender, \\\"Can only be called by token creator\\\");\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC721/ERC721CreatorExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"../CreatorExtension.sol\\\";\\n\\n/**\\n * @dev Base ERC721 creator extension variables\\n */\\nabstract contract ERC721CreatorExtension is CreatorExtension {\\n\\n    /**\\n     * @dev Legacy extension interface identifiers (see CreatorExtension for more)\\n     *\\n     * {IERC165-supportsInterface} needs to return 'true' for this interface\\n     * in order backwards compatible with older creator contracts\\n     */\\n\\n    // Required to be recognized as a contract to receive onBurn for older creator contracts\\n    bytes4 constant internal LEGACY_ERC721_EXTENSION_BURNABLE_INTERFACE = 0xf3f4e68b;\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC721/ERC721CreatorExtensionApproveTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\n\\nimport \\\"../../core/IERC721CreatorCore.sol\\\";\\nimport \\\"./ERC721CreatorExtension.sol\\\";\\nimport \\\"./IERC721CreatorExtensionApproveTransfer.sol\\\";\\n\\n/**\\n * @dev Suggested implementation for extensions that require the creator to\\n * check with it before a transfer occurs\\n */\\nabstract contract ERC721CreatorExtensionApproveTransfer is AdminControl, ERC721CreatorExtension, IERC721CreatorExtensionApproveTransfer {\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AdminControl, CreatorExtension, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721CreatorExtensionApproveTransfer).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorExtensionApproveTransfer-setApproveTransfer}\\n     */\\n    function setApproveTransfer(address creator, bool enabled) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC721CreatorCore).interfaceId), \\\"creator must implement IERC721CreatorCore\\\");\\n        IERC721CreatorCore(creator).setApproveTransferExtension(enabled);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/mocks/MockERC721CreatorExtensionOverride.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../core/IERC721CreatorCore.sol\\\";\\nimport \\\"../extensions/ERC721/ERC721CreatorExtensionApproveTransfer.sol\\\";\\nimport \\\"../extensions/ICreatorExtensionTokenURI.sol\\\";\\n\\ncontract MockERC721CreatorExtensionOverride is ERC721CreatorExtensionApproveTransfer, ICreatorExtensionTokenURI {\\n\\n    bool _approveEnabled;\\n    string _tokenURI;\\n    address _creator;\\n\\n    constructor(address creator) {\\n        _creator = creator;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721CreatorExtensionApproveTransfer, IERC165) returns (bool) {\\n        return interfaceId == type(ICreatorExtensionTokenURI).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    function testMint(address to) external {\\n        IERC721CreatorCore(_creator).mintExtension(to);\\n    }\\n\\n    function setApproveEnabled(bool enabled) public {\\n        _approveEnabled = enabled;\\n    }\\n\\n    function setTokenURI(string calldata uri) public {\\n        _tokenURI = uri;\\n    }\\n\\n    function approveTransfer(address, address, uint256) external view virtual override returns (bool) {\\n        return _approveEnabled;\\n    }\\n\\n    function tokenURI(address creator, uint256) external view virtual override returns (string memory) {\\n        require(creator == _creator, \\\"Invalid\\\");\\n        return _tokenURI;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC1155CreatorExtensionOverride.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../core/IERC1155CreatorCore.sol\\\";\\nimport \\\"../extensions/ERC1155/ERC1155CreatorExtensionApproveTransfer.sol\\\";\\nimport \\\"../extensions/ICreatorExtensionTokenURI.sol\\\";\\n\\ncontract MockERC1155CreatorExtensionOverride is ERC1155CreatorExtensionApproveTransfer, ICreatorExtensionTokenURI {\\n\\n    bool _approveEnabled;\\n    string _tokenURI;\\n    address _creator;\\n\\n    constructor(address creator) {\\n        _creator = creator;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155CreatorExtensionApproveTransfer, IERC165) returns (bool) {\\n        return interfaceId == type(ICreatorExtensionTokenURI).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    function testMintNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external {\\n        IERC1155CreatorCore(_creator).mintExtensionNew(to, amounts, uris);\\n    }\\n\\n    function setApproveEnabled(bool enabled) public {\\n        _approveEnabled = enabled;\\n    }\\n\\n    function setTokenURI(string calldata uri) public {\\n        _tokenURI = uri;\\n    }\\n\\n    function approveTransfer(address, address, uint256[] calldata, uint256[] calldata) external view virtual override returns (bool) {\\n       return _approveEnabled;\\n    }\\n\\n    function tokenURI(address creator, uint256) external view virtual override returns (string memory) {\\n        require(creator == _creator, \\\"Invalid\\\");\\n        return _tokenURI;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ERC1155/ERC1155CreatorExtensionApproveTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\n\\nimport \\\"../../core/IERC1155CreatorCore.sol\\\";\\nimport \\\"./IERC1155CreatorExtensionApproveTransfer.sol\\\";\\n\\n/**\\n * @dev Suggested implementation for extensions that require the creator to\\n * check with it before a transfer occurs\\n */\\nabstract contract ERC1155CreatorExtensionApproveTransfer is AdminControl, IERC1155CreatorExtensionApproveTransfer {\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AdminControl, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155CreatorExtensionApproveTransfer).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorExtensionApproveTransfer-setApproveTransfer}\\n     */\\n    function setApproveTransfer(address creator, bool enabled) external override adminRequired {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC1155CreatorCore).interfaceId), \\\"creator must implement IERC1155CreatorCore\\\");\\n        IERC1155CreatorCore(creator).setApproveTransferExtension(enabled);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/permissions/ERC1155/ERC1155CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\nimport \\\"../../core/IERC1155CreatorCore.sol\\\";\\nimport \\\"./IERC1155CreatorMintPermissions.sol\\\";\\n\\n/**\\n * @dev Basic implementation of a permission contract that works with a singular creator contract.\\n * approveMint requires the sender to be the configured creator.\\n */\\nabstract contract ERC1155CreatorMintPermissions is ERC165, AdminControl, IERC1155CreatorMintPermissions {\\n     address internal immutable _creator;\\n\\n     constructor(address creator_) {\\n         require(ERC165Checker.supportsInterface(creator_, type(IERC1155CreatorCore).interfaceId), \\\"Must implement IERC1155CreatorCore\\\");\\n         _creator = creator_;\\n     }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165, AdminControl) returns (bool) {\\n        return interfaceId == type(IERC1155CreatorMintPermissions).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorMintPermissions-approve}.\\n     */\\n    function approveMint(address, address[] calldata, uint256[] calldata, uint256[] calldata)  public virtual override {\\n        require(msg.sender == _creator, \\\"Can only be called by token creator\\\");\\n    }\\n     \\n\\n\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC1155/ERC1155CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\n\\nimport \\\"../../core/IERC1155CreatorCore.sol\\\";\\nimport \\\"./IERC1155CreatorExtensionBurnable.sol\\\";\\n\\n/**\\n * @dev Suggested implementation for extensions that want to receive onBurn callbacks\\n * Mint tracks the creators/tokens created, and onBurn only accepts callbacks from\\n * the creator of a token created.\\n */\\nabstract contract ERC1155CreatorExtensionBurnable is AdminControl, IERC1155CreatorExtensionBurnable {\\n\\n    mapping (uint256 => address) private _tokenCreators;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AdminControl, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155CreatorExtensionBurnable).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev batch mint a token\\n     */\\n    function mintNew(address creator, address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external adminRequired returns (uint256[] memory) {\\n        return _mintNew(creator, to, amounts, uris);\\n    }\\n\\n    function _mintNew(address creator, address[] calldata to, uint256[] calldata amounts, string[] calldata uris) internal returns (uint256[] memory tokenIds) {\\n        require(ERC165Checker.supportsInterface(creator, type(IERC1155CreatorCore).interfaceId), \\\"creator must implement IERC1155CreatorCore\\\");\\n        tokenIds = IERC1155CreatorCore(creator).mintExtensionNew(to, amounts, uris);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _tokenCreators[tokenIds[i]] = creator;\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155CreatorExtension-onBurn}.\\n     */\\n    function onBurn(address, uint256[] calldata tokenIds, uint256[] calldata) public virtual override {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(_tokenCreators[tokenIds[i]] == msg.sender, \\\"Can only be called by token creator\\\");\\n        }\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/mocks/MockERC1155CreatorExtensionBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../extensions/ERC1155/ERC1155CreatorExtensionBurnable.sol\\\";\\nimport \\\"../extensions/CreatorExtensionBasic.sol\\\";\\n\\ncontract MockERC1155CreatorExtensionBurnable is CreatorExtensionBasic, ERC1155CreatorExtensionBurnable {\\n    uint256 [] _mintedTokens;\\n    mapping(uint256 => uint256) _burntTokens;\\n    address _creator;\\n    \\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorExtensionBasic, ERC1155CreatorExtensionBurnable) returns (bool) {\\n        return CreatorExtensionBasic.supportsInterface(interfaceId) || ERC1155CreatorExtensionBurnable.supportsInterface(interfaceId);\\n    }\\n\\n    constructor(address creator) {\\n        _creator = creator;\\n    }\\n\\n    function testMintNew(address[] calldata to, uint256[] calldata amounts, string[] calldata uris) external {\\n        uint256[] memory tokenIds = _mintNew(_creator, to, amounts, uris);\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _mintedTokens.push(tokenIds[i]);\\n        }\\n    }\\n\\n    function testMintExisting(address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) external {\\n        IERC1155CreatorCore(_creator).mintExtensionExisting(to, tokenIds, amounts);\\n    }\\n\\n    function mintedTokens() external view returns(uint256[] memory) {\\n        return _mintedTokens;\\n    }\\n\\n    function burntTokens(uint256 tokenId) external view returns(uint256) {\\n        return _burntTokens[tokenId];\\n    }\\n\\n    function onBurn(address to, uint256[] calldata tokenIds, uint256[] calldata amounts) public override {\\n        ERC1155CreatorExtensionBurnable.onBurn(to, tokenIds, amounts);\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _burntTokens[tokenIds[i]] += amounts[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\ncontract MockERC721 is ERC721 {\\n\\n    constructor (string memory _name, string memory _symbol) ERC721(_name, _symbol) {\\n    }\\n\\n    function testMint(address to, uint256 tokenId) external {\\n        _mint(to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721CreatorEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\n\\nimport \\\"./ERC721Creator.sol\\\";\\nimport \\\"./core/ERC721CreatorCoreEnumerable.sol\\\";\\n\\n/**\\n * @dev ERC721Creator implementation (with enumerable api's)\\n */\\ncontract ERC721CreatorEnumerable is ERC721Creator, ERC721CreatorCoreEnumerable, ERC721Enumerable {\\n\\n    constructor (string memory _name, string memory _symbol) ERC721Creator(_name, _symbol) {\\n    }\\n        \\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Creator, ERC721CreatorCoreEnumerable, ERC721Enumerable) returns (bool) {\\n        return interfaceId == type(IERC721CreatorCoreEnumerable).interfaceId || ERC721Creator.supportsInterface(interfaceId) || ERC721Enumerable.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Enumerable, ERC721Creator, ERC721CreatorCoreEnumerable) {\\n        _approveTransfer(from, to, tokenId);\\n        ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\\n    }\\n\\n    function _postMintBase(address to, uint256 tokenId) internal virtual override(ERC721CreatorCore, ERC721CreatorCoreEnumerable) {\\n        ERC721CreatorCoreEnumerable._postMintBase(to, tokenId);\\n    }\\n\\n    function _postMintExtension(address to, uint256 tokenId) internal virtual override(ERC721CreatorCore, ERC721CreatorCoreEnumerable) {\\n        ERC721CreatorCoreEnumerable._postMintExtension(to, tokenId);\\n    }\\n\\n    function _postBurn(address owner, uint256 tokenId) internal virtual override(ERC721CreatorCore, ERC721CreatorCoreEnumerable) {\\n        ERC721CreatorCoreEnumerable._postBurn(owner, tokenId);\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view virtual override(ERC721Creator, ERC721) returns (string memory) {\\n        return ERC721Creator.tokenURI(tokenId);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/ERC721Creator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\nimport \\\"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\\\";\\nimport \\\"./core/ERC721CreatorCore.sol\\\";\\n\\n/**\\n * @dev ERC721Creator implementation\\n */\\ncontract ERC721Creator is AdminControl, ERC721, ERC721CreatorCore {\\n\\n    constructor (string memory _name, string memory _symbol) ERC721(_name, _symbol) {\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721CreatorCore, AdminControl) returns (bool) {\\n        return ERC721CreatorCore.supportsInterface(interfaceId) || ERC721.supportsInterface(interfaceId) || AdminControl.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n        _approveTransfer(from, to, tokenId);    \\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-registerExtension}.\\n     */\\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external override adminRequired nonBlacklistRequired(extension) {\\n        _registerExtension(extension, baseURI, baseURIIdentical);\\n    }\\n\\n\\n    /**\\n     * @dev See {ICreatorCore-unregisterExtension}.\\n     */\\n    function unregisterExtension(address extension) external override adminRequired {\\n        _unregisterExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-blacklistExtension}.\\n     */\\n    function blacklistExtension(address extension) external override adminRequired {\\n        _blacklistExtension(extension);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri, false);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURIExtension}.\\n     */\\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external override extensionRequired {\\n        _setBaseTokenURIExtension(uri, identical);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefixExtension}.\\n     */\\n    function setTokenURIPrefixExtension(string calldata prefix) external override extensionRequired {\\n        _setTokenURIPrefixExtension(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external override extensionRequired {\\n        _setTokenURIExtension(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIExtension}.\\n     */\\n    function setTokenURIExtension(uint256[] memory tokenIds, string[] calldata uris) external override extensionRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURIExtension(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setBaseTokenURI}.\\n     */\\n    function setBaseTokenURI(string calldata uri) external override adminRequired {\\n        _setBaseTokenURI(uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURIPrefix}.\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external override adminRequired {\\n        _setTokenURIPrefix(prefix);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256 tokenId, string calldata uri) external override adminRequired {\\n        _setTokenURI(tokenId, uri);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setTokenURI}.\\n     */\\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external override adminRequired {\\n        require(tokenIds.length == uris.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            _setTokenURI(tokenIds[i], uris[i]);            \\n        }\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setMintPermissions}.\\n     */\\n    function setMintPermissions(address extension, address permissions) external override adminRequired {\\n        _setMintPermissions(extension, permissions);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBase}.\\n     */\\n    function mintBase(address to) public virtual override nonReentrant adminRequired returns(uint256) {\\n        return _mintBase(to, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBase}.\\n     */\\n    function mintBase(address to, string calldata uri) public virtual override nonReentrant adminRequired returns(uint256) {\\n        return _mintBase(to, uri);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBaseBatch}.\\n     */\\n    function mintBaseBatch(address to, uint16 count) public virtual override nonReentrant adminRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](count);\\n        for (uint16 i = 0; i < count; i++) {\\n            tokenIds[i] = _mintBase(to, \\\"\\\");\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintBaseBatch}.\\n     */\\n    function mintBaseBatch(address to, string[] calldata uris) public virtual override nonReentrant adminRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](uris.length);\\n        for (uint i = 0; i < uris.length; i++) {\\n            tokenIds[i] = _mintBase(to, uris[i]);\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev Mint token with no extension\\n     */\\n    function _mintBase(address to, string memory uri) internal virtual returns(uint256 tokenId) {\\n        _tokenCount++;\\n        tokenId = _tokenCount;\\n\\n        // Track the extension that minted the token\\n        _tokensExtension[tokenId] = address(this);\\n\\n        _safeMint(to, tokenId);\\n\\n        if (bytes(uri).length > 0) {\\n            _tokenURIs[tokenId] = uri;\\n        }\\n\\n        // Call post mint\\n        _postMintBase(to, tokenId);\\n        return tokenId;\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtension}.\\n     */\\n    function mintExtension(address to) public virtual override nonReentrant extensionRequired returns(uint256) {\\n        return _mintExtension(to, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtension}.\\n     */\\n    function mintExtension(address to, string calldata uri) public virtual override nonReentrant extensionRequired returns(uint256) {\\n        return _mintExtension(to, uri);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtensionBatch}.\\n     */\\n    function mintExtensionBatch(address to, uint16 count) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](count);\\n        for (uint16 i = 0; i < count; i++) {\\n            tokenIds[i] = _mintExtension(to, \\\"\\\");\\n        }\\n        return tokenIds;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-mintExtensionBatch}.\\n     */\\n    function mintExtensionBatch(address to, string[] calldata uris) public virtual override nonReentrant extensionRequired returns(uint256[] memory tokenIds) {\\n        tokenIds = new uint256[](uris.length);\\n        for (uint i = 0; i < uris.length; i++) {\\n            tokenIds[i] = _mintExtension(to, uris[i]);\\n        }\\n    }\\n    \\n    /**\\n     * @dev Mint token via extension\\n     */\\n    function _mintExtension(address to, string memory uri) internal virtual returns(uint256 tokenId) {\\n        _tokenCount++;\\n        tokenId = _tokenCount;\\n\\n        _checkMintPermissions(to, tokenId);\\n\\n        // Track the extension that minted the token\\n        _tokensExtension[tokenId] = msg.sender;\\n\\n        _safeMint(to, tokenId);\\n\\n        if (bytes(uri).length > 0) {\\n            _tokenURIs[tokenId] = uri;\\n        }\\n        \\n        // Call post mint\\n        _postMintExtension(to, tokenId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-tokenExtension}.\\n     */\\n    function tokenExtension(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _tokenExtension(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCore-burn}.\\n     */\\n    function burn(uint256 tokenId) public virtual override nonReentrant {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"Caller is not owner nor approved\\\");\\n        address owner = ownerOf(tokenId);\\n        _burn(tokenId);\\n        _postBurn(owner, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(address(this), receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyalties}.\\n     */\\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        _setRoyalties(tokenId, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev See {ICreatorCore-setRoyaltiesExtension}.\\n     */\\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external override adminRequired {\\n        _setRoyaltiesExtension(extension, receivers, basisPoints);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getRoyalties}.\\n     */\\n    function getRoyalties(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFees}.\\n     */\\n    function getFees(uint256 tokenId) external view virtual override returns (address payable[] memory, uint256[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyalties(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeRecipients}.\\n     */\\n    function getFeeRecipients(uint256 tokenId) external view virtual override returns (address payable[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyReceivers(tokenId);\\n    }\\n\\n    /**\\n     * @dev {See ICreatorCore-getFeeBps}.\\n     */\\n    function getFeeBps(uint256 tokenId) external view virtual override returns (uint[] memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyBPS(tokenId);\\n    }\\n    \\n    /**\\n     * @dev {See ICreatorCore-royaltyInfo}.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view virtual override returns (address, uint256) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _getRoyaltyInfo(tokenId, value);\\n    } \\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"Nonexistent token\\\");\\n        return _tokenURI(tokenId);\\n    }\\n    \\n}\"\r\n    },\r\n    \"contracts/core/ERC721CreatorCoreEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"./ERC721CreatorCore.sol\\\";\\nimport \\\"./IERC721CreatorCoreEnumerable.sol\\\";\\n\\n/**\\n * @dev Core ERC721 creator implementation (with enumerable api's)\\n */\\nabstract contract ERC721CreatorCoreEnumerable is ERC721CreatorCore, IERC721CreatorCoreEnumerable {\\n    using Strings for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // For enumerating tokens for a given extension\\n    mapping (address => uint256) private _extensionBalances;\\n    mapping (address => mapping(uint256 => uint256)) private _extensionTokens;\\n    mapping (uint256 => uint256) private _extensionTokensIndex;\\n\\n    // For enumerating an extension's tokens for an owner\\n    mapping (address => mapping(address => uint256)) private _extensionBalancesByOwner;\\n    mapping (address => mapping(address => mapping(uint256 => uint256))) private _extensionTokensByOwner;\\n    mapping (uint256 => uint256) private _extensionTokensIndexByOwner;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721CreatorCore, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721CreatorCoreEnumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC721CreatorCoreEnumerable-totalSupplyExtension}.\\n     */\\n    function totalSupplyExtension(address extension) public view virtual override nonBlacklistRequired(extension) returns (uint256) {\\n        return _extensionBalances[extension];\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCoreEnumerable-tokenByIndexExtension}.\\n     */\\n    function tokenByIndexExtension(address extension, uint256 index) external view virtual override nonBlacklistRequired(extension) returns (uint256) {\\n        require(index < totalSupplyExtension(extension), \\\"ERC721Creator: Index out of bounds\\\");\\n        return _extensionTokens[extension][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCoreEnumerable-balanceOfExtension}.\\n     */\\n    function balanceOfExtension(address extension, address owner) public view virtual override nonBlacklistRequired(extension) returns (uint256) {\\n        return _extensionBalancesByOwner[extension][owner];\\n    }\\n\\n    /*\\n     * @dev See {IERC721CeratorCoreEnumerable-tokenOfOwnerByIndexExtension}.\\n     */\\n    function tokenOfOwnerByIndexExtension(address extension, address owner, uint256 index) external view virtual override nonBlacklistRequired(extension) returns (uint256) {\\n        require(index < balanceOfExtension(extension, owner), \\\"ERC721Creator: Index out of bounds\\\");\\n        return _extensionTokensByOwner[extension][owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCoreEnumerable-totalSupplyBase}.\\n     */\\n    function totalSupplyBase() public view virtual override returns (uint256) {\\n        return _extensionBalances[address(this)];\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCoreEnumerable-tokenByIndexBase}.\\n     */\\n    function tokenByIndexBase(uint256 index) external view virtual override returns (uint256) {\\n        require(index < totalSupplyBase(), \\\"ERC721Creator: Index out of bounds\\\");\\n        return _extensionTokens[address(this)][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721CreatorCoreEnumerable-balanceOfBase}.\\n     */\\n    function balanceOfBase(address owner) public view virtual override returns (uint256) {\\n        return _extensionBalancesByOwner[address(this)][owner];\\n    }\\n\\n    /*\\n     * @dev See {IERC721CeratorCoreEnumerable-tokenOfOwnerByIndeBase}.\\n     */\\n    function tokenOfOwnerByIndexBase(address owner, uint256 index) external view virtual override returns (uint256) {\\n        require(index < balanceOfBase(owner), \\\"ERC721Creator: Index out of bounds\\\");\\n        return _extensionTokensByOwner[address(this)][owner][index];\\n    }\\n\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId, address tokenExtension_) private {\\n        // Add to extension token tracking by owner\\n        uint256 lengthByOwner = balanceOfExtension(tokenExtension_, to);\\n        _extensionTokensByOwner[tokenExtension_][to][lengthByOwner] = tokenId;\\n        _extensionTokensIndexByOwner[tokenId] = lengthByOwner;\\n        _extensionBalancesByOwner[tokenExtension_][to] += 1;        \\n    }\\n\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId, address tokenExtension_) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n        uint256 lastTokenIndexByOwner = balanceOfExtension(tokenExtension_, from) - 1;\\n        uint256 tokenIndexByOwner = _extensionTokensIndexByOwner[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndexByOwner != lastTokenIndexByOwner) {\\n            uint256 lastTokenIdByOwner = _extensionTokensByOwner[tokenExtension_][from][lastTokenIndexByOwner];\\n\\n            _extensionTokensByOwner[tokenExtension_][from][tokenIndexByOwner] = lastTokenIdByOwner; // Move the last token to the slot of the to-delete token\\n            _extensionTokensIndexByOwner[lastTokenIdByOwner] = tokenIndexByOwner; // Update the moved token's index\\n        }\\n        _extensionBalancesByOwner[tokenExtension_][from] -= 1;\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _extensionTokensIndexByOwner[tokenId];\\n        delete _extensionTokensByOwner[tokenExtension_][from][lastTokenIndexByOwner];\\n    }\\n    \\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {\\n        if (from != address(0) && to != address(0)) {\\n            address tokenExtension_ = _tokenExtension(tokenId);\\n            if (from != to) {\\n                _removeTokenFromOwnerEnumeration(from, tokenId, tokenExtension_);\\n            }\\n            if (to != from) {\\n                _addTokenToOwnerEnumeration(to, tokenId, tokenExtension_);\\n            }\\n        }\\n    }\\n\\n    function _postMintBase(address to, uint256 tokenId) internal virtual override {\\n        // Add to extension token tracking\\n        uint256 length = totalSupplyBase();\\n        _extensionTokens[address(this)][length] = tokenId;\\n        _extensionTokensIndex[tokenId] = length;\\n        _extensionBalances[address(this)] += 1;\\n\\n        _addTokenToOwnerEnumeration(to, tokenId, address(this));\\n    }\\n\\n    function _postMintExtension(address to, uint256 tokenId) internal virtual override {\\n        // Add to extension token tracking\\n        uint256 length = totalSupplyExtension(msg.sender);\\n        _extensionTokens[msg.sender][length] = tokenId;\\n        _extensionTokensIndex[tokenId] = length;\\n        _extensionBalances[msg.sender] += 1;\\n\\n        _addTokenToOwnerEnumeration(to, tokenId, msg.sender);\\n    }\\n    \\n    function _postBurn(address owner, uint256 tokenId) internal override(ERC721CreatorCore) virtual {\\n        address tokenExtension_ = _tokensExtension[tokenId];\\n\\n        /*************************************************\\n         *  START: Remove from extension token tracking\\n         *************************************************/\\n\\n        uint256 lastTokenIndex = totalSupplyExtension(tokenExtension_) - 1;\\n        uint256 tokenIndex = _extensionTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _extensionTokens[tokenExtension_][lastTokenIndex];\\n\\n            _extensionTokens[tokenExtension_][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _extensionTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n        _extensionBalances[tokenExtension_] -= 1;\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _extensionTokensIndex[tokenId];\\n        delete _extensionTokens[tokenExtension_][lastTokenIndex];\\n\\n        /*************************************************\\n         * END\\n         *************************************************/\\n\\n\\n        /********************************************************\\n         *  START: Remove from extension token tracking by owner\\n         ********************************************************/\\n         _removeTokenFromOwnerEnumeration(owner, tokenId, tokenExtension_);\\n\\n        /********************************************************\\n         *  END\\n         ********************************************************/\\n         \\n         ERC721CreatorCore._postBurn(owner, tokenId);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/core/IERC721CreatorCoreEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"./IERC721CreatorCore.sol\\\";\\n\\n/**\\n * @dev Core ERC721 creator interface (with enumerable api's)\\n */\\ninterface IERC721CreatorCoreEnumerable is IERC721CreatorCore {\\n\\n    /*\\n     * @dev gets the total number of tokens created by the extension (unburned)\\n     */\\n    function totalSupplyExtension(address extension) external view returns (uint256);\\n\\n    /*\\n     * @dev gets tokenId of an extension by index. \\n     * Iterate over this to get the full list of tokens of a given extension\\n     */\\n    function tokenByIndexExtension(address extension, uint256 index) external view returns (uint256);\\n\\n    /*\\n     * @dev get balance of owner for an extension\\n     */\\n   function balanceOfExtension(address extension, address owner) external view returns (uint256 balance);\\n\\n   /*\\n    * @dev Returns a token ID owned by `owner` at a given `index` of its token list for a given extension\\n    */\\n   function tokenOfOwnerByIndexExtension(address extension, address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /*\\n     * @dev gets the total number of tokens created with no extension\\n     */\\n    function totalSupplyBase() external view returns (uint256);\\n\\n    /*\\n     * @dev gets tokenId of the root creator contract by index. \\n     * Iterate over this to get the full list of tokens with no extension.\\n     */\\n    function tokenByIndexBase(uint256 index) external view returns (uint256);\\n\\n    /*\\n     * @dev get balance of owner for tokens with no extension\\n     */\\n    function balanceOfBase(address owner) external view returns (uint256 balance);\\n\\n    /*\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list for tokens with no extension\\n     */\\n    function tokenOfOwnerByIndexBase(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n\\ncontract MockERC1155 is ERC1155 {\\n\\n    constructor (string memory uri_) ERC1155(uri_){\\n    }\\n\\n    function testMint(address account, uint256 id, uint256 amount, bytes calldata data) external {\\n        _mint(account, id, amount, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC1155CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../permissions/ERC1155/ERC1155CreatorMintPermissions.sol\\\";\\n\\ncontract MockERC1155CreatorMintPermissions is ERC1155CreatorMintPermissions {\\n    bool _approveEnabled;\\n\\n    constructor(address creator_) ERC1155CreatorMintPermissions (creator_) {\\n        _approveEnabled = true;\\n    }\\n\\n    function setApproveEnabled(bool enabled) external {\\n        _approveEnabled = enabled;\\n    }\\n\\n    function approveMint(address extension, address[] calldata to, uint256[] calldata tokenIds, uint256[] calldata amounts) public override {\\n        ERC1155CreatorMintPermissions.approveMint(extension, to, tokenIds, amounts);\\n        require(_approveEnabled, \\\"MockERC1155CreatorMintPermissions: Disabled\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC721CreatorMintPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../permissions/ERC721/ERC721CreatorMintPermissions.sol\\\";\\n\\ncontract MockERC721CreatorMintPermissions is ERC721CreatorMintPermissions {\\n    bool _approveEnabled;\\n\\n    constructor(address creator_) ERC721CreatorMintPermissions (creator_) {\\n        _approveEnabled = true;\\n    }\\n\\n    function setApproveEnabled(bool enabled) external {\\n        _approveEnabled = enabled;\\n    }\\n\\n    function approveMint(address extension, address to, uint256 tokenId) public override {\\n        ERC721CreatorMintPermissions.approveMint(extension, to, tokenId);\\n        require(_approveEnabled, \\\"MockERC721CreatorMintPermissions: Disabled\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"
  },
  "contractNames": {
    "0x0000000000c2d145a2526bd8c716263bfebe1a72": "TransferHelper",
    "0x1e0049783f008a0085193e00003d00cd54003c71": "Conduit",
    "0xbe072760153ec7432c36713daba89a4c45de63a0": "TIJSIB",
    "0x6bf5ed59de0e19999d264746843ff931c0133090": "ERC1155CreatorImplementation",
    "0x4721dfe67fe46381e2e56eb1e0406e0989bd7b8e": "ArtDubaiAlexisChristodoulou",
    "0x000000000000aaeb6d7670e522a718067333cd4e": "OperatorFilterRegistry",
    "0x3aebb320a0c06465c66bb0a027f6522912e14287": "SHOWDEER",
    "0xe4e4003afe3765aca8149a82fc064c0b125b9e5a": "ERC721CreatorImplementation"
  },
  "abis": {}
}
